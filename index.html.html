<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TUTU STORE</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>
        /* Load local font */
        @font-face {
            font-family: 'Joystix Monospace';
            src: url('fonts/joystix/joystix monospace.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        /* Admin Panel Styles */
        #admin-panel {
            position: fixed;
            top: 0;
            right: -450px;
            width: 450px;
            height: 100vh;
            background: #fffbe0;
            border-left: 5px solid #7ca0c7;
            box-shadow: -5px 0 20px rgba(0,0,0,0.3);
            z-index: 10000;
            transition: right 0.3s ease;
            overflow-y: auto;
            font-family: Arial, sans-serif;
        }
        
        #admin-panel.open {
            right: 0;
        }
        
        #admin-header {
            background: #24528b;
            color: white;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 3px solid #f64b23;
        }
        
        #admin-header h2 {
            margin: 0;
            font-size: 1.3em;
        }
        
        #admin-close {
            background: #f64b23;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        #admin-close:hover {
            background: #d43a13;
        }
        
        #admin-content {
            padding: 20px;
        }
        
        #admin-category-selector {
            background: white;
            padding: 20px;
            border: 3px solid #7ca0c7;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        #admin-category-selector h3 {
            margin-top: 0;
            color: #24528b;
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        
        .admin-category-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .admin-category-btn {
            padding: 12px 20px;
            border: 2px solid #7ca0c7;
            background: white;
            color: #24528b;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .admin-category-btn:hover {
            background: #e8f4f8;
            transform: scale(1.05);
        }
        
        .admin-category-btn.active {
            background: #24528b;
            color: white;
            border-color: #24528b;
        }
        
        .admin-category-fields {
            display: none;
        }
        
        .admin-category-fields.active {
            display: block;
        }
        
        #admin-form-section {
            background: white;
            padding: 20px;
            border: 3px solid #7ca0c7;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        #admin-form-section h3 {
            margin-top: 0;
            color: #24528b;
            font-size: 1.2em;
        }
        
        .admin-form-group {
            margin-bottom: 15px;
        }
        
        .admin-form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #24528b;
        }
        
        .admin-form-group input,
        .admin-form-group textarea {
            width: 100%;
            padding: 8px;
            border: 2px solid #7ca0c7;
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }
        
        .admin-form-group input::placeholder,
        .admin-form-group textarea::placeholder {
            color: #999;
            font-style: italic;
        }
        
        .admin-form-group input:focus,
        .admin-form-group textarea:focus {
            outline: none;
            border-color: #f64b23;
        }
        
        .admin-form-group input[type="file"] {
            padding: 5px;
            cursor: pointer;
        }
        
        .admin-form-group textarea {
            resize: vertical;
            min-height: 100px;
        }
        
        .admin-form-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .admin-form-actions button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
        }
        
        #admin-submit {
            background: #24528b;
            color: white;
        }
        
        #admin-submit:hover {
            background: #1a3d6b;
        }
        
        #admin-cancel-edit {
            background: #999;
            color: white;
        }
        
        #admin-cancel-edit:hover {
            background: #777;
        }
        
        #admin-products-list {
            background: white;
            padding: 20px;
            border: 3px solid #7ca0c7;
            border-radius: 8px;
        }
        
        #admin-products-list h3 {
            margin-top: 0;
            color: #24528b;
            font-size: 1.2em;
        }
        
        .admin-product-item {
            background: #f0f8ff;
            padding: 15px;
            margin-bottom: 15px;
            border: 2px solid #7ca0c7;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .admin-product-item img {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border: 2px solid #24528b;
            border-radius: 4px;
        }
        
        .admin-product-info {
            flex: 1;
        }
        
        .admin-product-info h4 {
            margin: 0 0 5px 0;
            color: #24528b;
            font-size: 1.1em;
        }
        
        .admin-product-info p {
            margin: 5px 0;
            color: #666;
            font-size: 0.9em;
        }
        
        .admin-product-info b {
            color: #f64b23;
            font-size: 1.1em;
        }
        
        .admin-product-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .admin-product-actions button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
        }
        
        .admin-edit-btn {
            background: #24528b;
            color: white;
        }
        
        .admin-edit-btn:hover {
            background: #1a3d6b;
        }
        
        .admin-delete-btn {
            background: #f64b23;
            color: white;
        }
        
        .admin-delete-btn:hover {
            background: #d43a13;
        }
        
        #admin-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: none;
        }
        
        #admin-overlay.active {
            display: block;
        }
        
        @media (max-width: 768px) {
            #admin-panel {
                width: 100%;
                right: -100%;
            }
            
            /* Mobile fixes for coffee product detail */
            #product-detail-envelope {
                flex-direction: column;
                gap: 20px;
            }
            
            #product-detail-image-section {
                width: 100%;
                min-width: 100%;
            }
            
            #product-detail-table-section {
                width: 100%;
                min-width: 100%;
            }
            
            /* Volume and Quantity Row - Mobile */
            .product-detail-volume-quantity-row {
                flex-wrap: nowrap !important;
                gap: 10px !important;
                align-items: center;
            }
            
            .volume-section {
                flex: 0 0 auto !important;
                flex-shrink: 1;
            }
            
            .volume-label {
                font-size: 0.9em;
            }
            
            .volume-select {
                min-width: 90px !important;
                max-width: 90px !important;
                width: 90px !important;
                font-size: 0.9em;
                padding: 6px 8px;
            }
            
            .product-detail-quantity-controls {
                flex: 0 0 auto !important;
                flex-shrink: 0;
            }
            
            /* Add to Cart Button Row - Mobile */
            .product-detail-cart-button-row {
                width: 100%;
                margin-top: 10px;
            }
            
            .product-detail-cart-button-row button {
                width: 100%;
            }
            
            /* Total Price Row - Mobile */
            .product-detail-total-price-row {
                width: 100%;
                margin-top: 10px;
            }
            
            /* Product Detail Quantity Tag - Mobile */
            #product-detail-quantity-tag {
                gap: 15px;
                width: 100%;
            }
            
            /* Product Detail Modal - Mobile */
            #product-detail-body {
                padding: 20px 15px;
            }
            
            #product-detail-image-section {
                margin-bottom: 15px;
            }
            
            /* Ensure proper spacing between elements */
            .product-detail-price-row {
                margin-bottom: 10px;
            }
            
            .product-detail-total-price-row {
                margin-bottom: 10px;
            }
            
            /* Coffee About Sections - Mobile */
            .coffee-about-section {
                padding: 20px 15px;
                overflow-wrap: break-word;
                word-wrap: break-word;
                word-break: break-word;
            }
            
            .coffee-about-section div {
                overflow-wrap: break-word;
                word-wrap: break-word;
                word-break: break-word;
                max-width: 100%;
            }
        }
        
        /* Coffee Product Card Styles */
        .coffee-product {
            display: flex;
            flex-direction: column;
            background: white !important;
            border: 3px solid black !important;
            position: relative;
        }
        
        .coffee-product img {
            width: 120% !important;
            height: auto !important;
            min-height: 200px;
            border: none !important;
            margin: -10px 0 10px 0;
            object-fit: cover;
            background: transparent !important;
            display: block;
            position: relative;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .coffee-card-info {
            margin: 10px 0;
            text-align: center;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            align-items: center;
        }
        
        .coffee-main-heading {
            font-weight: bold;
            color: #24528b;
            font-size: 1.2em;
            margin-bottom: 6px;
            text-align: center;
        }
        
        .coffee-brand {
            color: #666;
            font-size: 0.95em;
            margin-bottom: 4px;
            text-align: center;
        }
        
        .coffee-process {
            color: #888;
            font-size: 0.9em;
            font-style: italic;
            margin-bottom: 4px;
            text-align: center;
        }
        
        .coffee-package-size {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 6px;
            text-align: center;
        }
        
        .coffee-price {
            font-weight: bold;
            color: #f64b23;
            font-size: 1em;
            margin-top: 8px;
            text-align: center;
            padding-top: 8px;
            border-top: 2px solid #24528b;
        }
        
        .coffee-price-tag {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border: 2px solid #000;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 22px;
            font-weight: bold;
            color: #000;
            z-index: 15;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.2);
            opacity: 1;
            display: flex !important;
            align-items: center !important;
            justify-content: center;
            gap: 10px;
            pointer-events: none;
            line-height: 1 !important;
            margin-top: 10px;
        }
        
        .coffee-price-tag span {
            line-height: 1 !important;
            display: inline-flex !important;
            align-items: center !important;
            height: 100%;
        }
        
        .coffee-add-to-cart-btn {
            background: #24528b !important;
            color: yellow !important;
            border: 2px solid #000 !important;
            padding: 8px 16px !important;
            font-family: 'Joystix Monospace', 'Courier New', monospace !important;
            font-size: 14px !important;
            font-weight: bold !important;
            cursor: pointer;
            white-space: nowrap;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.2) !important;
            transition: background 0.2s ease;
            pointer-events: auto;
            border-radius: 0 !important;
            margin-top: 12px !important;
            margin-left: auto !important;
            margin-right: auto !important;
            line-height: 1 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            height: auto !important;
            width: fit-content;
        }
        
        .coffee-add-to-cart-btn:hover {
            background: #fffd72 !important;
            color: #24528b !important;
            border: 2px solid #000 !important;
        }
        
        .coffee-add-to-cart-btn.in-cart {
            background: #4caf50;
            color: white;
            border: 2px inset #2e7d32;
            cursor: default;
        }
        
        .coffee-add-to-cart-btn.in-cart:hover {
            background: #4caf50;
            color: white;
            border: 2px inset #2e7d32;
        }
        
        /* Coffee Details Table in Modal */
        .coffee-details-table {
            width: 100%;
            margin: 0;
            border-collapse: separate;
            border-spacing: 0 10px;
            border: none;
        }
        
        .coffee-details-table tr {
            border: none;
        }
        
        .coffee-table-label {
            font-weight: 500;
            color: #24528b;
            padding: 12px 18px;
            background: #f5f5f5;
            width: 35%;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-size: 0.9em;
            border-radius: 8px 0 0 8px;
            border: none;
            vertical-align: top;
        }
        
        .coffee-table-value {
            color: #222;
            padding: 12px 18px;
            background: #e8e8e8;
            font-size: 1.05em;
            font-weight: 600;
            border-radius: 0 8px 8px 0;
            border: none;
            vertical-align: top;
            line-height: 1.5;
        }
        
        .coffee-table-value:empty::before {
            content: '-';
            color: #999;
            font-weight: 300;
        }
        
        /* Coffee About Sections - Full Width Blocks */
        .coffee-about-section {
            width: 100%;
            margin: 20px 0;
            padding: 25px 30px;
            background: #fffbe0;
            border: 3px solid #7ca0c7;
            border-radius: 8px;
            box-sizing: border-box;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
            overflow: hidden;
        }
        
        .coffee-about-section:first-of-type {
            margin-top: 0;
        }
        
        .coffee-about-section h3 {
            color: #24528b;
            font-size: 1.4em;
            margin: 0 0 20px 0;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            border-bottom: 2px solid #7ca0c7;
            padding-bottom: 10px;
        }
        
        .coffee-about-section div {
            color: #333;
            line-height: 1.8;
            font-size: 1.05em;
            text-align: left;
            word-wrap: break-word;
            overflow-wrap: break-word;
            word-break: break-word;
            max-width: 100%;
            overflow: hidden;
        }
        
        /* Product Detail Modal Updates for Coffee */
        #product-detail-content {
            position: relative;
        }
        
        #product-detail-close-wrapper {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            pointer-events: none;
            z-index: 2001;
            width: auto;
            height: auto;
        }
        
        #product-detail-close {
            position: relative !important;
            top: 0 !important;
            right: 0 !important;
            left: auto !important;
            bottom: auto !important;
            z-index: 2002;
            pointer-events: auto;
        }
        
        #product-detail-body {
            display: flex;
            flex-direction: column;
            padding: 30px;
            gap: 0;
        }
        
        #product-detail-name {
            display: none;
        }
        
        #product-detail-envelope {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        #product-detail-image-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 250px;
        }
        
        #product-detail-image-container {
            width: 100%;
            text-align: center;
        }
        
        #product-detail-image-container img {
            width: 100%;
            max-width: 100%;
            height: auto;
            border: none !important;
            display: block;
            border-radius: 8px;
        }
        
        #product-detail-quantity-tag {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: flex-start;
            width: 100%;
        }
        
        /* Price Row - Big and Important */
        .product-detail-price-row {
            font-size: 2em;
            color: #f64b23;
            font-weight: bold;
            text-align: left;
            padding: 15px 0;
            font-family: 'Joystix Monospace', monospace;
            width: 100%;
            -webkit-text-stroke: 3px white;
            paint-order: stroke fill;
            text-shadow: 
                0 0 0 white,
                3px 3px 0 white,
                -3px -3px 0 white,
                3px -3px 0 white,
                -3px 3px 0 white,
                4px 4px 0 #f64b23,
                -4px -4px 0 #f64b23,
                4px -4px 0 #f64b23,
                -4px 4px 0 #f64b23;
        }
        
        /* Volume and Quantity Row */
        .product-detail-volume-quantity-row {
            display: flex !important;
            flex-direction: row !important;
            align-items: center;
            gap: 20px;
            width: 100%;
            flex-wrap: nowrap;
            margin-left: 20px;
        }
        
        .volume-section {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 0 0 auto;
            flex-shrink: 0;
        }
        
        .product-detail-quantity-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
            flex: 0 0 auto;
        }
        
        .volume-label {
            font-weight: bold;
            color: #24528b;
            font-size: 1.1em;
            white-space: nowrap;
            font-family: 'Joystix Monospace', monospace;
        }
        
        .volume-select {
            padding: 8px 12px;
            font-size: 1em;
            border: 2px solid #000;
            border-radius: 4px;
            background: white;
            color: #222;
            font-family: 'Joystix Monospace', monospace;
            min-width: 105px;
            max-width: 105px;
            width: 105px;
            cursor: pointer;
            height: 36px;
            box-sizing: border-box;
        }
        
        /* Add to Cart Button Row */
        .product-detail-cart-button-row {
            display: flex;
            align-items: flex-start;
            width: 100%;
            margin: 0;
            padding: 0;
        }
        
        .product-detail-cart-button-row button {
            margin: 0;
            margin-top: 0 !important;
            padding-top: 6px !important;
        }
        
        .quantity-counter {
            font-weight: bold;
            color: #24528b;
            min-width: 25px;
            text-align: center;
            font-size: 1em;
            background: #f9d677;
            padding: 4px 8px;
            border-radius: 4px;
            border: 2px solid #000;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 28px;
        }
        
        .product-detail-quantity-column {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
        }
        
        /* Total Price Row */
        .product-detail-total-price-row {
            display: flex;
            flex-direction: column;
            gap: 5px;
            width: 100%;
            margin-left: 20px;
        }
        
        .total-price-label {
            font-size: 1.1em;
            color: #24528b;
            font-weight: bold;
            text-align: left;
            font-family: 'Joystix Monospace', monospace;
        }
        
        .total-price-value {
            font-size: 1.35em;
            color: #f64b23;
            font-weight: bold;
            text-align: left;
            font-family: 'Joystix Monospace', monospace;
        }
        
        .product-detail-quantity-controls .quantity-btn {
            background: #24528b;
            color: yellow;
            border: 2px solid #000;
            border-radius: 4px;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1em;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .product-detail-quantity-controls .quantity-btn:hover {
            background: #fffd72;
            color: #24528b;
            border: 2px solid #000;
        }
        
        .product-detail-quantity-controls .quantity-btn:active {
            transform: translateY(1px);
        }
        
        #product-detail-add-cart {
            font-size: 1em;
            background: #24528b;
            color: yellow;
            border: 2px outset #f9d677;
            border-radius: 8px;
            padding: 10px 20px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            box-shadow: 4px 4px #e4c36d;
        }
        
        .coffee-detail-add-cart-btn {
            background: #24528b !important;
            color: yellow !important;
            border: 2px solid #000 !important;
            padding: 6px 14px !important;
            font-family: 'Joystix Monospace', 'Courier New', monospace !important;
            font-size: 13px !important;
            font-weight: bold !important;
            cursor: pointer;
            white-space: nowrap;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.2) !important;
            transition: background 0.2s ease;
            border-radius: 4px !important;
            height: 36px !important;
            box-sizing: border-box !important;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .coffee-detail-add-cart-btn:hover {
            background: #fffd72 !important;
            color: #24528b !important;
            border: 2px solid #000 !important;
        }
        
        .coffee-detail-add-cart-btn.in-cart {
            background: #4caf50 !important;
            color: white !important;
            border: 2px inset #2e7d32 !important;
            cursor: default;
        }
        
        .coffee-detail-add-cart-btn.in-cart:hover {
            background: #4caf50 !important;
            color: white !important;
            border: 2px inset #2e7d32 !important;
        }
        
        #product-detail-add-cart:hover {
            background: #fffd72;
            color: #24528b;
            border: 2px inset #7ca0c7;
        }
        
        #product-detail-add-cart.in-cart {
            background: #4caf50;
            color: white;
            border: 2px inset #2e7d32;
        }
        
        #product-detail-table-section {
            flex: 1;
            min-width: 250px;
        }
        
        #coffee-details-table {
            width: 100%;
            margin-top: 0;
        }
        
        #product-detail-description {
            margin-top: 20px;
            color: #444;
            line-height: 1.6;
            font-size: 1.1em;
            display: block;
            opacity: 0;
            max-height: 0;
            margin-top: 0;
            margin-bottom: 0;
            padding-top: 0;
            padding-bottom: 0;
            overflow: hidden;
            transition: opacity 0.4s ease, max-height 0.4s ease, margin 0.4s ease, padding 0.4s ease;
        }
        
        #product-detail-description.visible {
            opacity: 1;
            max-height: 2000px;
            margin-top: 20px;
            margin-bottom: 20px;
            padding-top: 15px;
            padding-bottom: 15px;
        }
        
        @media (max-width: 768px) {
            #product-detail-envelope {
                flex-direction: column;
                gap: 20px;
            }
            
            #product-detail-image-container {
                width: 100%;
            }
            
            #product-detail-image-container img {
                max-width: 100%;
            }
            
            .coffee-table-label,
            .coffee-table-value {
                padding: 10px 12px;
                font-size: 0.9em;
            }
        }
        
        /* Music Record Player Card Styles - 8-bit Pixelated */
        .music-products {
            display: flex;
            gap: 20px;
            flex-wrap: nowrap;
            justify-content: flex-start;
        }
        
        .record-player-card {
            width: 280px;
            background: #fffbe0;
            border: 4px solid #000;
            border-radius: 0;
            padding: 20px;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .record-player-base {
            width: 240px;
            height: 200px;
            background: #4a6fa5;
            border: 3px solid #2c3d5a;
            border-radius: 0;
            position: relative;
            margin-bottom: 15px;
            box-shadow: inset 2px 2px 0 #3a5a8a, inset -2px -2px 0 #5a7fb5;
            image-rendering: pixelated;
        }
        
        .record-disc {
            width: 160px;
            height: 160px;
            background: #6b5b95;
            border-radius: 50%;
            position: absolute;
            top: 20px;
            left: 40px;
            border: 2px solid #4a3d6a;
            box-shadow: 2px 2px 0 #7b6ba5, -2px -2px 0 #5a4b85;
            transition: transform 0.3s ease;
            image-rendering: pixelated;
            overflow: hidden;
        }
        
        .record-album-art {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            z-index: 1;
            image-rendering: pixelated;
        }
        
        .record-disc::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                repeating-linear-gradient(0deg, transparent 0px, transparent 2px, rgba(139, 123, 181, 0.3) 2px, rgba(139, 123, 181, 0.3) 4px),
                repeating-linear-gradient(90deg, transparent 0px, transparent 2px, rgba(123, 107, 165, 0.3) 2px, rgba(123, 107, 165, 0.3) 4px);
            background-size: 8px 8px;
            z-index: 2;
            pointer-events: none;
        }
        
        .record-player-card.playing .record-disc {
            animation: spin 3s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        @keyframes spinReverse {
            from { transform: rotate(360deg); }
            to { transform: rotate(0deg); }
        }
        
        .speed-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: bold;
            z-index: 20;
            opacity: 1;
            transition: opacity 1s ease;
            pointer-events: none;
            box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-family: 'Orbitron', monospace;
        }
        
        .record-center {
            width: 40px;
            height: 40px;
            background: #2c3d5a;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid #4a5a7a;
            box-shadow: inset 2px 2px 0 #3a4d6a, inset -2px -2px 0 #1c2d4a;
            z-index: 5;
        }
        
        .record-lines {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 140px;
            z-index: 4;
            height: 140px;
            border-radius: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent 0px,
                transparent 3px,
                rgba(200, 180, 255, 0.2) 3px,
                rgba(200, 180, 255, 0.2) 6px
            );
            image-rendering: pixelated;
        }
        
        .record-arm {
            position: absolute;
            top: 25px;
            right: -35px;
            width: 80px;
            height: 100px;
            transform-origin: 20px 20px;
            transition: transform 0.5s ease;
            image-rendering: pixelated;
            z-index: 6;
        }
        
        .record-player-card.playing .record-arm {
            transform: rotate(25deg);
        }
        
        .arm-base {
            width: 20px;
            height: 20px;
            background: #5a6fa5;
            border-radius: 0;
            position: absolute;
            top: 0;
            left: 0;
            border: 2px solid #3a4d7a;
            box-shadow: inset 1px 1px 0 #6a7fb5, inset -1px -1px 0 #4a5d8a;
        }
        
        .arm-rod {
            width: 4px;
            height: 70px;
            background: #4a5a8a;
            position: absolute;
            top: 20px;
            left: 8px;
            border: 1px solid #3a4a7a;
            box-shadow: 1px 0 0 #5a6a9a, -1px 0 0 #3a4a7a;
        }
        
        .arm-head {
            width: 12px;
            height: 12px;
            background: #5a6fa5;
            border-radius: 0;
            position: absolute;
            top: 90px;
            left: 4px;
            border: 2px solid #3a4d7a;
            box-shadow: inset 1px 1px 0 #6a7fb5, inset -1px -1px 0 #4a5d8a;
        }
        
        .play-button-wrapper {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }
        
        .play-button,
        .skip-button {
            width: 60px;
            height: 60px;
            border-radius: 0;
            background: #ff8c42;
            color: white;
            border: 3px solid #cc6a2a;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.3), inset 1px 1px 0 rgba(255,255,255,0.2);
            transition: all 0.2s ease;
            image-rendering: pixelated;
            font-family: 'Courier New', monospace;
            z-index: 10;
            position: relative;
        }
        
        .skip-button {
            width: 48px;
            height: 48px;
            font-size: 19px;
        }
        
        .skip-button:hover,
        .play-button:hover {
            background: #ff9c52;
            transform: scale(1.1);
        }
        
        .play-button.playing {
            background: #8b7bb5;
        }
        
        .music-info {
            text-align: center;
            width: 100%;
        }
        
        .music-info h3 {
            margin: 10px 0 5px 0;
            color: #24528b;
            font-size: 1.2em;
        }
        
        .music-info p {
            margin: 5px 0;
            color: #666;
            font-size: 0.9em;
        }
        
        .music-info b {
            color: #f64b23;
            font-size: 1.1em;
            display: block;
            margin-top: 10px;
        }
        
        .youtube-player-container {
            width: 1px;
            height: 1px;
            position: absolute;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        .youtube-player-container iframe {
            width: 1px;
            height: 1px;
            border: none;
        }
        
    </style>
</head>
<!--
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        O P E N   U   R   E S H O P
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-->
<body bgcolor="#c4d7ed" link="yellow" vlink="#24528b" alink="#f64b23">
    <marquee scrollamount="8" direction="left"><span style="display: inline-block; margin-left: -70vw;"></span>welcome to tutucafe eshop, place where you can buy delicious coffee and selection of cool stuff to gift yourself or the others â€¢ welcome to tutucafe eshop, place where you can buy delicious coffee and selection of cool stuff to gift yourself or the others</marquee>

        <h1>
            <img src="media/tutu_1line_white_background.png" alt="Tutu Shop">
        </h1>
    <!-- Desktop Navigation - Categories Left -->
    <div id="nav-categories">
        <a href="#" data-category="coffee" class="nav-btn category-link active"><span>COFFEE</span></a>
        <a href="#" data-category="fashion" class="nav-btn category-link"><span>FASHION</span></a>
        <a href="#" data-category="arts" class="nav-btn category-link"><span>ARTS</span></a>
        <a href="#" data-category="crafts" class="nav-btn category-link"><span>CRAFTS</span></a>
        <a href="#" data-category="music" class="nav-btn category-link"><span>MUSIC</span></a>
    </div>

    <!-- Desktop Navigation - Cart & Admin Right -->
    <div id="nav-cart-admin">
        <a href="#" id="cart-toggle" class="nav-btn cart-link"><span>ðŸ›’<br>CaRt<br><span id="cart-count">0</span></span></a>
        <a href="#" id="admin-toggle" class="nav-btn admin-link"><span>ðŸ”§ AdMiN</span></a>
        </div>

    <div id="container">
       
        <!-- Mobile Sticky Cart Button -->
        <a href="#" id="mobile-cart-toggle-sticky" class="mobile-cart-sticky"><span>ðŸ›’<br>CART<br><span id="mobile-cart-count-sticky">0</span></span></a>

        <div id="ski-game-section">
            <div id="ski-game-container">
                <canvas id="skiCanvas"></canvas>
                <div id="ski-game-controls">
                    <button id="ski-jump-btn" class="ski-control-btn">JUMP â¬†</button>
                </div>
                <div id="ski-game-score" style="font-size:1.1em;margin-top:12px;color:#f64b23;font-weight:bold;"></div>
            </div>
        </div>

        <script>
        // Horizontal Ski Game JavaScript
        (function() {
            const canvas = document.getElementById('skiCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const gameContainer = document.getElementById('ski-game-container');
            if (!gameContainer) return;
            
            // Calculate canvas size
            function calculateCanvasSize() {
                if (!canvas || !gameContainer) return;
                const isDesktop = window.innerWidth >= 1024;
                const containerWidth = gameContainer.offsetWidth;
                canvas.width = containerWidth;
                // Desktop: less tall, Mobile: taller
                if (isDesktop) {
                    canvas.height = containerWidth * 0.4;
                } else {
                    canvas.height = containerWidth * 1.1;
                }
            }
            
            // Game variables
            let skier = {
                x: 50,
                y: 0,
                width: 40,
                height: 50,
                velocityY: 0,
                isJumping: false,
                jumpCount: 0,
                maxJumps: 2,
                groundY: 0,
                onObstacle: null
            };
            
            let obstacles = [];
            let gameState = 0; // 0: start, 1: running, 2: over
            let score = 0;
            let bestScore = parseInt(localStorage.getItem('skiHi') || '0');
            let gameSpeed = 5;
            let baseSpeed = 5;
            let speedIncrease = 0.003;
            let scrollX = 0;
            let obstacleTimer = 0;
            let obstacleInterval = 100;
            
            // Cache background pattern
            let backgroundPattern = null;
            
            // Initialize
            function initGame() {
                if (!gameContainer || gameContainer.offsetWidth === 0) {
                    setTimeout(initGame, 10);
                    return;
                }
                calculateCanvasSize();
                // Initialize game but don't start it - wait for user input
                if (!canvas) return;
                skier.x = 50;
                skier.groundY = canvas.height - 80;
                skier.y = skier.groundY;
                skier.velocityY = 0;
                skier.isJumping = false;
                skier.jumpCount = 0;
                skier.onObstacle = null;
                obstacles = [];
                score = 0;
                gameSpeed = baseSpeed;
                scrollX = 0;
                obstacleTimer = 0;
                gameState = 0; // Start in start screen, don't auto-start
                setupCanvasEvents(); // Set up click/touch events after initialization
            }
            
            // Reset game
            function resetGame() {
                if (!canvas) return;
                skier.x = 50;
                skier.groundY = canvas.height - 80;
                skier.y = skier.groundY;
                skier.velocityY = 0;
                skier.isJumping = false;
                skier.jumpCount = 0;
                skier.onObstacle = null;
                obstacles = [];
                score = 0;
                gameSpeed = baseSpeed;
                scrollX = 0;
                obstacleTimer = 0;
                gameState = 1;
                addObstacle();
            }
            
            // Add obstacle
            function addObstacle() {
                if (!canvas) return;
                const types = ['tree', 'log', 'hole'];
                const type = types[Math.floor(Math.random() * types.length)];
                const width = type === 'hole' ? 60 : (type === 'log' ? 80 : 50);
                const height = type === 'hole' ? 40 : (type === 'log' ? 30 : 80);
                
                // All obstacles on the ground
                obstacles.push({
                    x: canvas.width + scrollX + 200,
                    y: type === 'hole' ? skier.groundY + skier.height - height : skier.groundY - height,
                    width: width,
                    height: height,
                    type: type,
                    passed: false
                });
            }
            
            // Create background pattern once
            function createBackgroundPattern() {
                if (backgroundPattern) return backgroundPattern;
                const patternCanvas = document.createElement('canvas');
                patternCanvas.width = 200;
                patternCanvas.height = 200;
                const patternCtx = patternCanvas.getContext('2d');
                patternCtx.fillStyle = "#e8f4f8";
                patternCtx.fillRect(0, 0, 200, 200);
                patternCtx.fillStyle = "#ffffff";
                for (let i = 0; i < 200; i += 20) {
                    for (let j = 0; j < 200; j += 20) {
                        if ((i + j) % 40 === 0) {
                            patternCtx.fillRect(i, j, 8, 8);
                        }
                    }
                }
                backgroundPattern = ctx.createPattern(patternCanvas, 'repeat');
                return backgroundPattern;
            }
            
            // Draw game
            function draw() {
                if (!ctx || !canvas) return;
                
                // Clear and draw background (pattern is cached, just reuse)
                if (!backgroundPattern) {
                    backgroundPattern = createBackgroundPattern();
                }
                ctx.fillStyle = backgroundPattern;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw ground line
                ctx.strokeStyle = "#24528b";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, skier.groundY + skier.height);
                ctx.lineTo(canvas.width, skier.groundY + skier.height);
                ctx.stroke();
                
                // Draw obstacles (only visible ones) - optimized
                const canvasRight = canvas.width;
                for (let i = 0; i < obstacles.length; i++) {
                    const obstacle = obstacles[i];
                    // Safety check - skip invalid obstacles
                    if (!obstacle || typeof obstacle.x !== 'number' || typeof obstacle.width !== 'number') {
                        continue;
                    }
                    const screenX = obstacle.x - scrollX;
                    // Skip obstacles completely off-screen
                    if (screenX + obstacle.width < 0 || screenX > canvasRight) continue;
                    
                    if (obstacle.type === 'tree') {
                        // Tree trunk
                        ctx.fillStyle = "#2d5016";
                        ctx.fillRect(screenX, obstacle.y, obstacle.width, obstacle.height);
                        // Tree top
                        ctx.beginPath();
                        ctx.moveTo(screenX + obstacle.width / 2, obstacle.y);
                        ctx.lineTo(screenX - 10, obstacle.y + obstacle.height * 0.5);
                        ctx.lineTo(screenX + obstacle.width + 10, obstacle.y + obstacle.height * 0.5);
                        ctx.closePath();
                        ctx.fill();
                    } else if (obstacle.type === 'log') {
                        // Log
                        ctx.fillStyle = "#8B4513";
                        ctx.fillRect(screenX, obstacle.y, obstacle.width, obstacle.height);
                        ctx.strokeStyle = "#654321";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenX, obstacle.y, obstacle.width, obstacle.height);
                    } else if (obstacle.type === 'hole') {
                        // Hole
                        ctx.fillStyle = "#1a1a2e";
                        ctx.fillRect(screenX, obstacle.y, obstacle.width, obstacle.height);
                        ctx.strokeStyle = "#000";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenX, obstacle.y, obstacle.width, obstacle.height);
                    }
                }
                
                // Draw skier
                ctx.fillStyle = "#f64b23";
                ctx.fillRect(skier.x, skier.y, skier.width, skier.height);
                // Skier head
                ctx.fillStyle = "#ffdbac";
                ctx.beginPath();
                ctx.arc(skier.x + skier.width / 2, skier.y, 12, 0, Math.PI * 2);
                ctx.fill();
                // Skis
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(skier.x - 5, skier.y + skier.height - 10, 15, 8);
                ctx.fillRect(skier.x + skier.width - 10, skier.y + skier.height - 10, 15, 8);
                
                // Draw score and text (optimized - set font once per state)
                ctx.textAlign = "center";
                
                if (gameState === 1) {
                    ctx.font = "bold 30px 'Joystix Monospace', monospace";
                    ctx.fillStyle = "#24528b";
                    ctx.fillText(score, canvas.width / 2, 40);
                } else if (gameState === 0) {
                    ctx.font = "bold 24px 'Joystix Monospace', monospace";
                    ctx.fillStyle = "#24528b";
                    const isMobile = window.innerWidth < 1024;
                    const startText = isMobile ? "Click to play" : "Press something to play";
                    ctx.fillText(startText, canvas.width / 2, canvas.height / 2);
                } else if (gameState === 2) {
                    ctx.font = "bold 28px 'Joystix Monospace', monospace";
                    ctx.fillStyle = "#f64b23";
                    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);
                    ctx.font = "bold 20px 'Joystix Monospace', monospace";
                    ctx.fillText("Score: " + score, canvas.width / 2, canvas.height / 2);
                    ctx.fillStyle = "#24528b";
                    ctx.fillText("Best: " + bestScore, canvas.width / 2, canvas.height / 2 + 30);
                    const isMobile = window.innerWidth < 1024;
                    const restartText = isMobile ? "Tap to try again" : "Press SPACE to try again";
                    ctx.fillText(restartText, canvas.width / 2, canvas.height / 2 + 60);
                }
            }
            
            // Update game
            function update() {
                if (gameState !== 1 || !canvas) return;
                
                // Increase speed gradually (cap max speed)
                gameSpeed = Math.min(gameSpeed + speedIncrease, 12);
                
                // Move scroll
                scrollX += gameSpeed;
                
                // Skier physics
                if (skier.isJumping || skier.velocityY !== 0) {
                    skier.velocityY += 0.8; // Gravity
                    skier.y += skier.velocityY;
                    
                    // Check if landing on obstacle (only check visible obstacles)
                    let landedOnObstacle = false;
                    const skierRight = skier.x + skier.width;
                    const skierBottom = skier.y + skier.height;
                    
                    for (let i = 0; i < obstacles.length; i++) {
                        const obstacle = obstacles[i];
                        const screenX = obstacle.x - scrollX;
                        // Only check obstacles near the skier
                        if (screenX > skierRight + 50 || screenX + obstacle.width < skier.x - 50) continue;
                        
                        if (obstacle.type !== 'hole' && 
                            skier.x < screenX + obstacle.width &&
                            skierRight > screenX &&
                            skierBottom <= obstacle.y + 5 &&
                            skierBottom >= obstacle.y - 5 &&
                            skier.velocityY > 0) {
                            // Landing on top of obstacle
                            skier.y = obstacle.y - skier.height;
                            skier.velocityY = 0;
                            skier.isJumping = false;
                            skier.jumpCount = 0;
                            skier.onObstacle = obstacle;
                            landedOnObstacle = true;
                            break;
                        }
                    }
                    
                    // Land on ground if not on obstacle
                    if (!landedOnObstacle && skier.y >= skier.groundY) {
                        skier.y = skier.groundY;
                        skier.velocityY = 0;
                        skier.isJumping = false;
                        skier.jumpCount = 0;
                        skier.onObstacle = null;
                    }
                }
                
                // Check if still on obstacle (obstacle might have moved)
                if (skier.onObstacle) {
                    const screenX = skier.onObstacle.x - scrollX;
                    if (skier.x < screenX + skier.onObstacle.width &&
                        skier.x + skier.width > screenX &&
                        skier.y + skier.height <= skier.onObstacle.y + 5) {
                        // Still on obstacle, keep position
                        skier.y = skier.onObstacle.y - skier.height;
                    } else {
                        // No longer on obstacle, start falling
                        skier.onObstacle = null;
                        skier.isJumping = true;
                    }
                }
                
                // Add obstacles
                obstacleTimer++;
                if (obstacleTimer >= obstacleInterval) {
                    addObstacle();
                    obstacleTimer = 0;
                    // Decrease interval as speed increases (more obstacles) - but keep minimum
                    obstacleInterval = Math.max(80, 150 - (gameSpeed - baseSpeed) * 15);
                }
                
                // Limit max obstacles to prevent memory issues (aggressive cleanup)
                if (obstacles.length > 30) {
                    // Remove all obstacles behind the screen more aggressively
                    for (let i = obstacles.length - 1; i >= 0; i--) {
                        const obs = obstacles[i];
                        if (!obs || typeof obs.x !== 'number' || obs.x - scrollX < -100) {
                            obstacles.splice(i, 1);
                        }
                    }
                }
                
                // Update obstacles (optimized collision detection)
                const skierRight = skier.x + skier.width;
                const skierBottom = skier.y + skier.height;
                const skierLeft = skier.x;
                const checkLeft = skierLeft - 50;
                const checkRight = skierRight + 50;
                let needsSave = false;
                
                for (let i = 0; i < obstacles.length; i++) {
                    const obstacle = obstacles[i];
                    // Safety check - skip invalid obstacles
                    if (!obstacle || typeof obstacle.x !== 'number' || typeof obstacle.width !== 'number') {
                        continue;
                    }
                    const screenX = obstacle.x - scrollX;
                    
                    // Check if passed for scoring (only once per obstacle)
                    if (!obstacle.passed && obstacle.x < scrollX + skier.x) {
                        score++;
                        obstacle.passed = true;
                        if (score > bestScore) {
                            bestScore = score;
                            needsSave = true;
                        }
                    }
                    
                    // Skip obstacles far from skier early (after scoring check)
                    if (screenX + obstacle.width < checkLeft || screenX > checkRight) {
                        continue;
                    }
                    
                    // Check collision - only die when hitting from left or bottom
                    const isOverlapping = (
                        skier.x < screenX + obstacle.width &&
                        skierRight > screenX &&
                        skier.y < obstacle.y + obstacle.height &&
                        skierBottom > obstacle.y
                    );
                    
                    if (isOverlapping) {
                        // Check if landing on top (allow this)
                        const landingOnTop = (
                            skierBottom <= obstacle.y + 5 &&
                            skier.velocityY >= 0 &&
                            skier.x + skier.width * 0.3 > screenX &&
                            skier.x + skier.width * 0.7 < screenX + obstacle.width
                        );
                        
                        // Only die if hitting from left or bottom (not from top)
                        if (!landingOnTop && obstacle.type !== 'hole') {
                            // Hitting from left side
                            const hittingFromLeft = (
                                skierRight <= screenX + 10 &&
                                skierBottom > obstacle.y &&
                                skier.y < obstacle.y + obstacle.height
                            );
                            
                            // Hitting from bottom
                            const hittingFromBottom = (
                                skier.y >= obstacle.y + obstacle.height - 10 &&
                                skier.x < screenX + obstacle.width &&
                                skierRight > screenX
                            );
                            
                            if (hittingFromLeft || hittingFromBottom) {
                                gameState = 2;
                                break;
                            }
                        } else if (obstacle.type === 'hole') {
                            // Holes always kill if you fall in
                            if (skierBottom > obstacle.y) {
                                gameState = 2;
                                break;
                            }
                        }
                    }
                }
                
                // Remove off-screen obstacles (optimized - iterate backwards for removal)
                // Only do this if we haven't already cleaned up above
                if (obstacles.length <= 30) {
                    for (let i = obstacles.length - 1; i >= 0; i--) {
                        const obs = obstacles[i];
                        if (!obs || typeof obs.x !== 'number' || obs.x - scrollX < -300) {
                            obstacles.splice(i, 1);
                        }
                    }
                }
                
                // Save high score (throttled for performance)
                if (needsSave) {
                    localStorage.setItem('skiHi', bestScore);
                }
                
                // Update score display
                updateScoreDisplay();
            }
            
            // Update score display
            function updateScoreDisplay() {
                const scoreEl = document.getElementById('ski-game-score');
                if (scoreEl) {
                    let txt = "";
                    if (bestScore) txt = "ðŸ”ï¸ Best run: " + bestScore;
                    scoreEl.innerText = txt;
                }
            }
            
            // Start game function
            function startGame() {
                if (gameState === 0) {
                    resetGame();
                }
            }
            
            // Jump function
            function jump() {
                if (gameState === 0) {
                    resetGame();
                } else if (gameState === 1) {
                    // Allow double jump
                    if (skier.jumpCount < skier.maxJumps) {
                        skier.velocityY = -15;
                        skier.isJumping = true;
                        skier.jumpCount++;
                        skier.onObstacle = null; // Leave obstacle when jumping
                    }
                } else if (gameState === 2) {
                    gameState = 0;
                }
            }
            
            // Canvas click/touch to start game - set up after initialization
            function setupCanvasEvents() {
                if (canvas) {
                    canvas.addEventListener('click', function(e) {
                        if (gameState === 0) {
                            startGame();
                            e.preventDefault();
                        }
                    });
                    
                    canvas.addEventListener('touchstart', function(e) {
                        if (gameState === 0) {
                            startGame();
                            e.preventDefault();
                        }
                    });
                }
            }
            
            // Keyboard controls
            document.addEventListener('keydown', function(e) {
                // Don't trigger game if admin panel is open or user is typing in an input/textarea
                const adminPanel = document.getElementById('admin-panel');
                const isAdminOpen = adminPanel && adminPanel.classList.contains('open');
                const isTyping = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
                
                // Start game on any key press if on start screen
                if (gameState === 0 && !isAdminOpen && !isTyping) {
                    startGame();
                    e.preventDefault();
                    return;
                }
                
                if (e.key === ' ' || e.key === 'Space' || e.keyCode === 32) {
                    // Only allow jump if admin is closed and not typing in a form field
                    if (!isAdminOpen && !isTyping) {
                        jump();
                        e.preventDefault();
                    }
                }
            });
            
            // Button controls for jumping
            const jumpBtn = document.getElementById('ski-jump-btn');
            if (jumpBtn) {
                jumpBtn.addEventListener('click', jump);
                jumpBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    jump();
                });
            }
            
            // Game loop
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
            
            // Initialize and start
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    setTimeout(initGame, 10);
                    gameLoop();
                });
            } else {
                setTimeout(initGame, 10);
                gameLoop();
            }
            
            // Recalculate on resize
            window.addEventListener('resize', function() {
                calculateCanvasSize();
                backgroundPattern = null; // Reset pattern on resize
                if (gameState === 1) {
                    resetGame();
                }
            });
        })();
        </script>

        <script>
        // Category navigation - smooth scroll to category
        document.addEventListener('DOMContentLoaded', function() {
            const categoryLinks = document.querySelectorAll('.category-link');
            const categorySections = document.querySelectorAll('.category-section');
            let isScrolling = false;

            categoryLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetCategory = this.getAttribute('data-category');

                    // Don't set active class on click - let scroll detection handle it
                    // Smooth scroll to the category section
                    const targetSection = document.querySelector(`.category-section[data-category="${targetCategory}"]`);
                    if (targetSection) {
                        isScrolling = true;
                        targetSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        // Reset scrolling flag after animation
                        setTimeout(() => {
                            isScrolling = false;
                        }, 1000);
                    }
                });
            });

            // Update active state based on scroll position
            function updateActiveOnScroll() {
                if (isScrolling) return; // Don't update while programmatically scrolling

                let currentActive = null;
                const viewportMiddle = window.innerHeight / 2;
                const scrollTop = window.scrollY || window.pageYOffset;

                // If we're at the very top of the page (before any category sections), don't set any as active
                if (scrollTop < 100) {
                    categoryLinks.forEach(l => l.classList.remove('active'));
                    return;
                }

                categorySections.forEach(section => {
                    const rect = section.getBoundingClientRect();
                    const category = section.getAttribute('data-category');
                    
                    // Check if section is significantly in viewport (at least 30% visible)
                    const sectionHeight = rect.height;
                    const visibleHeight = Math.min(rect.bottom, window.innerHeight) - Math.max(rect.top, 0);
                    const visibilityRatio = visibleHeight / sectionHeight;
                    
                    // Section is active if it's in the middle of viewport or significantly visible
                    if (rect.top <= viewportMiddle && rect.bottom >= viewportMiddle) {
                        currentActive = category;
                    } else if (rect.top <= 250 && rect.bottom >= 150 && visibilityRatio > 0.3) {
                        // Section is near the top and at least 30% visible
                        currentActive = category;
                    }
                });

                // If no section is clearly in view, find the one closest to the top (but only if scrolled past header)
                if (!currentActive && scrollTop > 100) {
                    let closestSection = null;
                    let closestDistance = Infinity;

                    categorySections.forEach(section => {
                        const rect = section.getBoundingClientRect();
                        // Only consider sections that are at least partially visible or just above viewport
                        if (rect.top < window.innerHeight && rect.bottom > 0) {
                            const distance = Math.abs(rect.top - 150); // Distance from ideal position
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestSection = section.getAttribute('data-category');
                            }
                        }
                    });

                    if (closestSection) {
                        currentActive = closestSection;
                    }
                }

                // Update active link
                if (currentActive) {
                    categoryLinks.forEach(l => l.classList.remove('active'));
                    const matchingLink = document.querySelector(`.category-link[data-category="${currentActive}"]`);
                    if (matchingLink) {
                        matchingLink.classList.add('active');
                    }
                } else if (scrollTop < 100) {
                    // At top of page, remove all active states
                    categoryLinks.forEach(l => l.classList.remove('active'));
                }
            }

            // Throttle scroll events for better performance
            let scrollTimeout;
            window.addEventListener('scroll', function() {
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }
                scrollTimeout = setTimeout(updateActiveOnScroll, 50);
            });

            // Initial check on load
            updateActiveOnScroll();
        });
        </script>

        <script>
        // Cart functionality - global cart variable
        let cart = JSON.parse(localStorage.getItem('cafe2000sCart')) || [];
        let cartSidebar, cartToggle, cartClose, cartOverlay, cartItems, cartEmpty, cartCount, cartTotalAmount, cartCheckout, cartClear;
        
        // Make addToCart globally accessible
        window.addToCart = function(name, price, image) {
            const existingItem = cart.find(item => item.name === name);
            if (existingItem) {
                existingItem.quantity += 1;
            } else {
                cart.push({ name, price, image, quantity: 1 });
            }
            saveCart();
            updateCartDisplay();
            if (typeof window.updateButtonStates === 'function') {
                window.updateButtonStates();
            }
            
            // Open cart sidebar
            const cartSidebarEl = document.getElementById('cart-sidebar');
            const cartOverlayEl = document.getElementById('cart-overlay');
            if (cartSidebarEl && cartOverlayEl) {
                cartSidebarEl.classList.add('open');
                cartOverlayEl.classList.add('active');
            }
        };

        document.addEventListener('DOMContentLoaded', function() {
            // Cart UI elements
            cartSidebar = document.getElementById('cart-sidebar');
            cartToggle = document.getElementById('cart-toggle');
            const mobileCartToggleSticky = document.getElementById('mobile-cart-toggle-sticky');
            cartClose = document.getElementById('cart-close');
            cartOverlay = document.getElementById('cart-overlay');
            cartItems = document.getElementById('cart-items');
            cartEmpty = document.getElementById('cart-empty');
            cartCount = document.getElementById('cart-count');
            const mobileCartCountSticky = document.getElementById('mobile-cart-count-sticky');
            cartTotalAmount = document.getElementById('cart-total-amount');
            cartCheckout = document.getElementById('cart-checkout');
            cartClear = document.getElementById('cart-clear');

            // Check if elements exist
            if (!cartSidebar || !cartToggle || !cartClose || !cartOverlay || !cartItems || !cartEmpty || !cartCount || !cartTotalAmount || !cartCheckout || !cartClear) {
                console.error('Cart elements not found!');
                return;
            }

            // Open/close cart - handle both desktop and mobile toggles
            function openCart(e) {
                if (e) e.preventDefault();
                cartSidebar.classList.add('open');
                cartOverlay.classList.add('active');
            }

            if (cartToggle) {
                cartToggle.addEventListener('click', openCart);
            }
            if (mobileCartToggleSticky) {
                mobileCartToggleSticky.addEventListener('click', openCart);
            }

            cartClose.addEventListener('click', closeCart);
            cartOverlay.addEventListener('click', closeCart);

            // Function to update button states based on cart (make it globally accessible)
            window.updateButtonStates = function() {
                // Update regular add-to-cart buttons
                document.querySelectorAll('.add-to-cart').forEach(button => {
                    const name = button.getAttribute('data-name');
                    const inCart = cart.find(item => item.name === name);
                    
                    if (inCart) {
                        button.classList.add('in-cart');
                        button.textContent = 'In CaRt âœ“';
                    } else {
                        button.classList.remove('in-cart');
                        button.textContent = 'AdD tO CaRt';
                    }
                });
                
                // Update fashion add-to-cart buttons
                document.querySelectorAll('.fashion-add-to-cart-btn').forEach(button => {
                    const product = button.closest('.fashion-product');
                    if (product) {
                        const name = product.getAttribute('data-name');
                        const inCart = cart.find(item => item.name === name);
                        
                        if (inCart) {
                            button.classList.add('in-cart');
                            button.textContent = 'In CaRt âœ“';
                        } else {
                            button.classList.remove('in-cart');
                            button.textContent = '+ CaRt';
                        }
                    }
                });
                
                // Update coffee add-to-cart buttons
                document.querySelectorAll('.coffee-add-to-cart-btn').forEach(button => {
                    const name = button.getAttribute('data-name');
                    // Check for exact match or any volume variant (card view uses 250g, detail view can use any volume)
                    const baseName = name ? name.replace(/ \(\d+g\)$/, '') : '';
                    const inCart = cart.find(item => {
                        if (item.name === name) return true;
                        // Check if it's the same coffee product (any volume)
                        if (baseName && item.name.startsWith(baseName + ' (')) return true;
                        return false;
                    });
                    
                    if (inCart) {
                        button.classList.add('in-cart');
                        button.textContent = 'In CaRt âœ“';
                    } else {
                        button.classList.remove('in-cart');
                        button.textContent = '+ CaRt';
                    }
                });
                
                // Update crafts add-to-cart buttons
                document.querySelectorAll('.crafts-add-to-cart-btn').forEach(button => {
                    const product = button.closest('.crafts-product');
                    if (product) {
                        const name = product.getAttribute('data-name');
                        const inCart = cart.find(item => item.name === name);
                        
                        if (inCart) {
                            button.classList.add('in-cart');
                            button.textContent = 'In CaRt âœ“';
                        } else {
                            button.classList.remove('in-cart');
                            button.textContent = '+ CaRt';
                        }
                    }
                });
                
                // Update art add-to-cart buttons
                document.querySelectorAll('.art-add-to-cart-btn').forEach(button => {
                    const frame = button.closest('.art-frame');
                    if (frame) {
                        const name = frame.getAttribute('data-name');
                        const inCart = cart.find(item => item.name === name);
                        
                        if (inCart) {
                            button.classList.add('in-cart');
                            button.textContent = 'In CaRt âœ“';
                        } else {
                            button.classList.remove('in-cart');
                            button.textContent = '+ CaRt';
                        }
                    }
                });
            };

            // Add to cart - use event delegation for dynamically added products
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('add-to-cart') || e.target.closest('.add-to-cart')) {
                    const button = e.target.classList.contains('add-to-cart') ? e.target : e.target.closest('.add-to-cart');
                    const name = button.getAttribute('data-name');
                    const price = parseFloat(button.getAttribute('data-price'));
                    const image = button.getAttribute('data-image');

                    if (!name || isNaN(price) || !image) {
                        console.error('Missing product data!', {name, price, image});
                        return;
                    }

                    // Check if item already in cart
                    const existingItem = cart.find(item => item.name === name);
                    if (existingItem) {
                        existingItem.quantity += 1;
                    } else {
                        cart.push({ name, price, image, quantity: 1 });
                    }

                    saveCart();
                    updateCartDisplay();
                    window.updateButtonStates();
                    
                    // Open cart sidebar
                    if (cartSidebar && cartOverlay) {
                        cartSidebar.classList.add('open');
                        cartOverlay.classList.add('active');
                    }
                }
            });

            // Clear cart
            cartClear.addEventListener('click', function() {
                if (confirm('R u SuRe U wAnT 2 ClEaR Ur CaRt? ðŸ˜¢')) {
                    cart = [];
                    saveCart();
                    updateCartDisplay();
                    window.updateButtonStates();
                }
            });

            // Checkout
            cartCheckout.addEventListener('click', function() {
                if (cart.length === 0) {
                    alert('Ur CaRt iS eMpTy! Add sum stuff 1st! ðŸ›’');
                    return;
                }
                const total = cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
                alert(`ThAnK U 4 Ur OrDeR! ðŸŽ‰\n\nToTaL: $${total.toFixed(2)}\n\nThIs Is A dEmO sHoP, sO nO rEaL cHaRgE! ðŸ˜Š`);
                cart = [];
                saveCart();
                updateCartDisplay();
                closeCart();
            });

            // Initialize cart display and button states
            updateCartDisplay();
            window.updateButtonStates();
        });

        function closeCart() {
            if (cartSidebar && cartOverlay) {
                cartSidebar.classList.remove('open');
                cartOverlay.classList.remove('active');
            }
        }

        // Remove from cart
        function removeFromCart(index) {
            if (index >= 0 && index < cart.length) {
                const removedItem = cart[index];
                cart.splice(index, 1);
                saveCart();
                updateCartDisplay();
                
                // Update product detail modal if it's open and showing this item
                const productDetailModal = document.getElementById('product-detail-modal');
                if (productDetailModal && productDetailModal.classList.contains('open')) {
                    const productDetailName = document.getElementById('product-detail-name');
                    if (productDetailName) {
                        const productName = productDetailName.textContent;
                        // Check if removed item matches the current product
                        if (removedItem.name === productName || removedItem.name.startsWith(productName) || (productName && removedItem.name.includes(productName.split(' (')[0]))) {
                            // Update quantity display to 1 (default)
                            const productDetailQuantity = document.getElementById('product-detail-quantity');
                            if (productDetailQuantity) {
                                productDetailQuantity.textContent = '1';
                            }
                            // Update total price
                            if (typeof window.updateProductDetailTotal === 'function') {
                                window.updateProductDetailTotal();
                            }
                            // Update add to cart button
                            if (typeof window.updateAddToCartButton === 'function') {
                                window.updateAddToCartButton(productName);
                            }
                        }
                    }
                }
                
                // Update button states when item is removed
                if (typeof window.updateButtonStates === 'function') {
                    window.updateButtonStates();
                }
            }
        }

        // Update quantity
        function updateQuantity(index, change) {
            if (index >= 0 && index < cart.length) {
                const cartItem = cart[index];
                cart[index].quantity += change;
                if (cart[index].quantity <= 0) {
                    removeFromCart(index);
                } else {
                    saveCart();
                    updateCartDisplay();
                    
                    // Update product detail modal if it's open and showing this item
                    const productDetailModal = document.getElementById('product-detail-modal');
                    if (productDetailModal && productDetailModal.classList.contains('open')) {
                        const productDetailName = document.getElementById('product-detail-name');
                        if (productDetailName) {
                            const productName = productDetailName.textContent;
                            // Check if this cart item matches the current product (with or without volume suffix)
                            if (cartItem.name === productName || cartItem.name.startsWith(productName) || productName && cartItem.name.includes(productName.split(' (')[0])) {
                                // Update quantity display
                                const productDetailQuantity = document.getElementById('product-detail-quantity');
                                if (productDetailQuantity) {
                                    productDetailQuantity.textContent = cart[index].quantity;
                                }
                                // Update total price
                                if (typeof window.updateProductDetailTotal === 'function') {
                                    window.updateProductDetailTotal();
                                }
                                // Update add to cart button
                                if (typeof window.updateAddToCartButton === 'function') {
                                    window.updateAddToCartButton(productName);
                                }
                            }
                        }
                    }
                }
                // Update button states when quantity changes
                if (typeof window.updateButtonStates === 'function') {
                    window.updateButtonStates();
                }
            }
        }

        // Save cart to localStorage
        function saveCart() {
            try {
                localStorage.setItem('cafe2000sCart', JSON.stringify(cart));
            } catch (e) {
                console.error('Error saving cart:', e);
            }
        }

        // Update cart display - make globally accessible
        function updateCartDisplay() {
            if (!cartCount || !cartTotalAmount || !cartItems || !cartEmpty) return;

            // Update count - both desktop and mobile
            const totalItems = cart.reduce((sum, item) => sum + item.quantity, 0);
            cartCount.textContent = totalItems;
            const mobileCartCountSticky = document.getElementById('mobile-cart-count-sticky');
            if (mobileCartCountSticky) {
                mobileCartCountSticky.textContent = totalItems;
            }

            // Update total
            const total = cart.reduce((sum, item) => sum + (item.price * item.quantity), 0);
            cartTotalAmount.textContent = total.toFixed(2);

            // Update items display
            if (cart.length === 0) {
                cartItems.innerHTML = '';
                if (cartEmpty) cartEmpty.style.display = 'block';
            } else {
                if (cartEmpty) cartEmpty.style.display = 'none';
                cartItems.innerHTML = cart.map((item, index) => `
                    <div class="cart-item">
                        <img src="${item.image}" alt="${item.name}">
                        <div class="cart-item-info">
                            <h4>${item.name}</h4>
                            <p>$${item.price.toFixed(2)} each</p>
                            <div class="cart-item-controls">
                                <button onclick="updateQuantity(${index}, -1)">âˆ’</button>
                                <span>${item.quantity}</span>
                                <button onclick="updateQuantity(${index}, 1)">+</button>
                            </div>
                            <div class="cart-item-total">$${(item.price * item.quantity).toFixed(2)}</div>
                        </div>
                        <button class="cart-item-remove" onclick="removeFromCart(${index})">âœ•</button>
                    </div>
                `).join('');
            }
            
            // Update detail modal if it's open
            const productDetailModal = document.getElementById('product-detail-modal');
            const productDetailName = document.getElementById('product-detail-name');
            if (productDetailModal && productDetailModal.classList.contains('open') && productDetailName) {
                const productName = productDetailName.textContent;
                if (productName && typeof window.initializeProductDetailQuantity === 'function') {
                    window.initializeProductDetailQuantity(productName);
                }
                // Also update the add to cart button
                if (productName && typeof window.updateAddToCartButton === 'function') {
                    window.updateAddToCartButton(productName);
                }
            }
        }
        
        // Make functions global for onclick handlers
        window.updateCartDisplay = updateCartDisplay;
        window.updateQuantity = updateQuantity;
        window.removeFromCart = removeFromCart;
        </script>

        <script>
        // Product Detail Modal functionality
        document.addEventListener('DOMContentLoaded', function() {
            const productDetailModal = document.getElementById('product-detail-modal');
            const productDetailOverlay = document.getElementById('product-detail-overlay');
            const productDetailClose = document.getElementById('product-detail-close');
            const productDetailImage = document.getElementById('product-detail-image');
            const productDetailName = document.getElementById('product-detail-name');
            const productDetailDescription = document.getElementById('product-detail-description');
            const productDetailQuantity = document.getElementById('product-detail-quantity');
            const productDetailQuantityMinus = document.getElementById('product-detail-quantity-minus');
            const productDetailQuantityPlus = document.getElementById('product-detail-quantity-plus');
            const productDetailTotalPrice = document.getElementById('product-detail-total-price');
            const productDetailAddCart = document.getElementById('product-detail-add-cart');
            let currentProductPrice = 0;

            if (!productDetailModal || !productDetailOverlay || !productDetailClose) {
                console.error('Product detail modal elements not found!');
                return;
            }

            // Make products clickable (except the button and coffee products)
            document.querySelectorAll('.product:not(.coffee-product)').forEach(product => {
                product.addEventListener('click', function(e) {
                    // Don't open if clicking the button
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }

                    const name = this.getAttribute('data-product-name') || (this.querySelector('h3') ? this.querySelector('h3').textContent : '');
                    const price = this.getAttribute('data-product-price') || (this.querySelector('b') ? this.querySelector('b').textContent.replace('$', '') : '0');
                    const image = this.getAttribute('data-product-image') || this.querySelector('img').src;
                    const short = this.getAttribute('data-product-short') || (this.querySelector('p') ? this.querySelector('p').textContent : '');
                    const description = this.getAttribute('data-product-description') || short;

                    openProductDetail(name, price, image, short, description);
                });

                // Add cursor pointer style
                product.style.cursor = 'pointer';
            });

            window.openProductDetail = function(name, price, image, short, description) {
                productDetailName.textContent = name;
                currentProductPrice = parseFloat(price) || 0;
                productDetailImage.src = image;
                productDetailImage.alt = name;
                
                // Hide package size and volume selector for non-coffee products
                const packageSizeEl = document.getElementById('product-detail-package-size');
                if (packageSizeEl) {
                    packageSizeEl.textContent = '';
                }
                const volumeSelectorContainer = document.getElementById('coffee-volume-selector-container');
                if (volumeSelectorContainer) {
                    volumeSelectorContainer.style.display = 'none';
                }
                // Clear current coffee product
                window.currentCoffeeProduct = null;
                if (productDetailDescription) {
                    productDetailDescription.innerHTML = description.replace(/\n/g, '<br>');
                    productDetailDescription.style.display = 'block';
                    // Use setTimeout to trigger transition after display is set
                    setTimeout(() => {
                        productDetailDescription.classList.add('visible');
                    }, 10);
                }
                
                // Hide coffee-specific sections
                const coffeeDetailsTable = document.getElementById('coffee-details-table');
                const aboutCoffeeSection = document.getElementById('coffee-about-section');
                const aboutFarmerSection = document.getElementById('coffee-farmer-section');
                const aboutRoasterySection = document.getElementById('coffee-roastery-section');
                if (coffeeDetailsTable) coffeeDetailsTable.style.display = 'none';
                if (aboutCoffeeSection) aboutCoffeeSection.style.display = 'none';
                if (aboutFarmerSection) aboutFarmerSection.style.display = 'none';
                if (aboutRoasterySection) aboutRoasterySection.style.display = 'none';

                // Initialize quantity from cart
                initializeProductDetailQuantity(name);

                // Show modal
                productDetailModal.classList.add('open');
                productDetailOverlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }
            
            // Open arts product with smooth zoom-in animation
            window.openArtsProductDetail = function(name, price, image, short, description, clickedElement) {
                // Get clicked card position for smooth transition
                let startRect = { left: 0, top: 0, width: 300, height: 300 };
                let originalAspectRatio = 1;
                
                if (clickedElement) {
                    const rect = clickedElement.getBoundingClientRect();
                    const frameInner = clickedElement.querySelector('.frame-inner');
                    const img = clickedElement.querySelector('img');
                    
                    // Get original dimensions from the frame-inner or image
                    if (frameInner) {
                        const frameRect = frameInner.getBoundingClientRect();
                        startRect = {
                            left: frameRect.left + frameRect.width / 2,
                            top: frameRect.top + frameRect.height / 2,
                            width: frameRect.width,
                            height: frameRect.height
                        };
                        originalAspectRatio = frameRect.width / frameRect.height;
                    } else if (img) {
                        const imgRect = img.getBoundingClientRect();
                        startRect = {
                            left: imgRect.left + imgRect.width / 2,
                            top: imgRect.top + imgRect.height / 2,
                            width: imgRect.width,
                            height: imgRect.height
                        };
                        originalAspectRatio = imgRect.width / imgRect.height;
                    }
                }
                
                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'art-zoom-overlay';
                overlay.style.display = 'flex';
                overlay.onclick = function(e) {
                    if (e.target === overlay || e.target === zoomContainer) {
                        closeArtsZoom();
                    }
                };
                
                // Create zoom container
                const zoomContainer = document.createElement('div');
                zoomContainer.className = 'art-zoom-container';
                
                // Create image wrapper
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'art-zoom-image-wrapper';
                
                // Create image
                const zoomImg = document.createElement('img');
                zoomImg.src = image;
                zoomImg.alt = name;
                zoomImg.className = 'art-zoom-image';
                
                // Wait for image to load to get actual dimensions
                zoomImg.onload = function() {
                    const imgAspectRatio = this.naturalWidth / this.naturalHeight;
                    const effectiveAspectRatio = originalAspectRatio || imgAspectRatio;
                    
                    // Set initial position and size (from clicked card)
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    
                    // Calculate target size maintaining aspect ratio
                    const maxWidth = Math.min(800, window.innerWidth * 0.8);
                    const maxHeight = Math.min(800, window.innerHeight * 0.8);
                    
                    let targetWidth, targetHeight;
                    if (effectiveAspectRatio > 1) {
                        // Landscape
                        targetWidth = Math.min(maxWidth, maxHeight * effectiveAspectRatio);
                        targetHeight = targetWidth / effectiveAspectRatio;
                    } else {
                        // Portrait or square
                        targetHeight = Math.min(maxHeight, maxWidth / effectiveAspectRatio);
                        targetWidth = targetHeight * effectiveAspectRatio;
                    }
                    
                    imageWrapper.style.left = startRect.left + 'px';
                    imageWrapper.style.top = startRect.top + 'px';
                    imageWrapper.style.width = startRect.width + 'px';
                    imageWrapper.style.height = startRect.height + 'px';
                    imageWrapper.style.transform = 'translate(-50%, -50%)';
                    
                    // Store target dimensions for close animation
                    imageWrapper._targetWidth = targetWidth;
                    imageWrapper._targetHeight = targetHeight;
                    imageWrapper._startWidth = startRect.width;
                    imageWrapper._startHeight = startRect.height;
                    imageWrapper._startLeft = startRect.left;
                    imageWrapper._startTop = startRect.top;
                    
                    // Trigger smooth zoom animation to center
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            imageWrapper.style.left = centerX + 'px';
                            imageWrapper.style.top = centerY + 'px';
                            imageWrapper.style.width = targetWidth + 'px';
                            imageWrapper.style.height = targetHeight + 'px';
                            overlay.style.opacity = '1';
                        });
                    });
                };
                
                // Add close button
                const closeBtn = document.createElement('button');
                closeBtn.className = 'art-zoom-close-btn';
                closeBtn.textContent = 'âœ•';
                closeBtn.onclick = function(e) {
                    e.stopPropagation();
                    closeArtsZoom();
                };
                imageWrapper.appendChild(closeBtn);
                
                // Add price tag and cart button
                const priceTag = document.createElement('div');
                priceTag.className = 'art-zoom-price-tag';
                
                const cartBtn = document.createElement('button');
                cartBtn.className = 'art-zoom-add-to-cart-btn';
                cartBtn.textContent = '+ CaRt';
                cartBtn.onclick = function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                    // Use the global addToCart function
                    if (typeof window.addToCart === 'function') {
                        window.addToCart(name, price, image);
                    }
                    if (typeof window.closeArtsZoom === 'function') {
                        window.closeArtsZoom();
                    }
                };
                
                const priceSpan = document.createElement('span');
                priceSpan.textContent = '$' + parseFloat(price).toFixed(2);
                priceTag.appendChild(priceSpan);
                priceTag.appendChild(cartBtn);
                imageWrapper.appendChild(priceTag);
                
                imageWrapper.appendChild(zoomImg);
                zoomContainer.appendChild(imageWrapper);
                overlay.appendChild(zoomContainer);
                document.body.appendChild(overlay);
                document.body.style.overflow = 'hidden';
                
                // Close function
                window.closeArtsZoom = function() {
                    if (!imageWrapper._startWidth) return; // Wait for image to load
                    
                    overlay.style.opacity = '0';
                    imageWrapper.style.left = imageWrapper._startLeft + 'px';
                    imageWrapper.style.top = imageWrapper._startTop + 'px';
                    imageWrapper.style.width = imageWrapper._startWidth + 'px';
                    imageWrapper.style.height = imageWrapper._startHeight + 'px';
                    
                    setTimeout(() => {
                        if (overlay.parentNode) {
                            overlay.parentNode.removeChild(overlay);
                        }
                        document.body.style.overflow = '';
                        delete window.closeArtsZoom;
                    }, 500);
                };
            }
            
            // Function to update close button position to stay fixed when scrolling
            // Close button is positioned with CSS (fixed in viewport top-right, 20px from edges)
            
            // Open coffee product detail with all information
            window.openCoffeeProductDetail = function(product) {
                if (!productDetailName || !productDetailImage) {
                    console.error('Product detail modal elements not found!');
                    return;
                }
                
                productDetailName.textContent = product.name || '';
                const basePrice = parseFloat(product.price) || 0;
                const basePackageSize = product.packageSize || '250g';
                // Extract numeric value from package size (e.g., "250g" -> 250)
                const baseSize = parseInt(basePackageSize.replace(/[^0-9]/g, '')) || 250;
                
                // Calculate price per 100g
                const pricePer100g = (basePrice / baseSize) * 100;
                
                // Store product data for volume calculation
                window.currentCoffeeProduct = {
                    ...product,
                    basePrice: basePrice,
                    baseSize: baseSize,
                    pricePer100g: pricePer100g
                };
                
                // Show volume selector for coffee products
                const volumeSelectorContainer = document.getElementById('coffee-volume-selector-container');
                const volumeSelect = document.getElementById('coffee-volume-select');
                if (volumeSelectorContainer && volumeSelect) {
                    volumeSelectorContainer.style.display = 'flex';
                    // Always default to smallest option (250g)
                    volumeSelect.value = '250';
                    // Calculate initial price
                    updateCoffeePriceByVolume();
                }
                
                productDetailImage.src = product.image || '';
                productDetailImage.alt = product.name || '';
                
                // Fill coffee details with null checks
                const setCoffeeDetail = function(id, value) {
                    const el = document.getElementById(id);
                    if (el) {
                        el.textContent = value || '-';
                    } else {
                        console.warn('Element not found:', id);
                    }
                };
                
                // Set all coffee details in table
                setCoffeeDetail('coffee-origin', product.origin);
                setCoffeeDetail('coffee-region', product.region);
                setCoffeeDetail('coffee-farmer', product.farmer);
                setCoffeeDetail('coffee-roastery', product.roastery);
                setCoffeeDetail('coffee-variety', product.variety);
                setCoffeeDetail('coffee-roast-type', product.roastType);
                setCoffeeDetail('coffee-process', product.process);
                setCoffeeDetail('coffee-flavour', product.flavour);
                setCoffeeDetail('coffee-roast-level', product.roastLevel);
                setCoffeeDetail('coffee-brewing', product.brewing);
                
                // Show/hide about sections
                const aboutCoffeeSection = document.getElementById('coffee-about-section');
                const aboutFarmerSection = document.getElementById('coffee-farmer-section');
                const aboutRoasterySection = document.getElementById('coffee-roastery-section');
                
                if (product.aboutCoffee) {
                    document.getElementById('coffee-about-coffee').innerHTML = product.aboutCoffee.replace(/\n/g, '<br>');
                    aboutCoffeeSection.style.display = 'block';
                } else {
                    aboutCoffeeSection.style.display = 'none';
                }
                
                if (product.aboutFarmer) {
                    document.getElementById('coffee-about-farmer').innerHTML = product.aboutFarmer.replace(/\n/g, '<br>');
                    aboutFarmerSection.style.display = 'block';
                } else {
                    aboutFarmerSection.style.display = 'none';
                }
                
                if (product.aboutRoastery) {
                    document.getElementById('coffee-about-roastery').innerHTML = product.aboutRoastery.replace(/\n/g, '<br>');
                    aboutRoasterySection.style.display = 'block';
                } else {
                    aboutRoasterySection.style.display = 'none';
                }
                
                // Hide old description fields (for non-coffee products)
                if (productDetailDescription) {
                    productDetailDescription.classList.remove('visible');
                    setTimeout(() => {
                        productDetailDescription.style.display = 'none';
                    }, 400); // Wait for transition to complete
                }
                
                // Show coffee details table
                const coffeeDetailsTable = document.getElementById('coffee-details-table');
                if (coffeeDetailsTable) coffeeDetailsTable.style.display = 'table';
                
                // Initialize quantity from cart
                initializeProductDetailQuantity(product.name);

                // Show modal
                productDetailModal.classList.add('open');
                productDetailOverlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            }

            window.closeProductDetail = function() {
                productDetailModal.classList.remove('open');
                productDetailModal.classList.remove('arts-product-detail');
                productDetailOverlay.classList.remove('active');
                document.body.style.overflow = '';
                
                // Clean up arts detail controls
                const productDetailImageContainer = document.getElementById('product-detail-image-container');
                if (productDetailImageContainer) {
                    const existingClose = productDetailImageContainer.querySelector('.art-detail-close-btn');
                    const existingPriceTag = productDetailImageContainer.querySelector('.art-detail-price-tag');
                    if (existingClose) existingClose.remove();
                    if (existingPriceTag) existingPriceTag.remove();
                }
                
                // Reset display of all fields for next use
                if (productDetailDescription) {
                    productDetailDescription.classList.remove('visible');
                    setTimeout(() => {
                        productDetailDescription.style.display = 'none';
                    }, 400); // Wait for transition to complete
                }
                const quantityTag = document.getElementById('product-detail-quantity-tag');
                if (quantityTag) quantityTag.style.display = 'flex';
                const coffeeDetailsTable = document.getElementById('coffee-details-table');
                if (coffeeDetailsTable) coffeeDetailsTable.style.display = 'none';
                
                // Hide volume selector
                const volumeSelectorContainer = document.getElementById('coffee-volume-selector-container');
                if (volumeSelectorContainer) {
                    volumeSelectorContainer.style.display = 'none';
                }
                
                // Clear current coffee product
                window.currentCoffeeProduct = null;
            }

            // Close handlers
            productDetailClose.addEventListener('click', window.closeProductDetail);
            productDetailOverlay.addEventListener('click', window.closeProductDetail);

            // Function to update total price based on quantity
            function updateProductDetailTotal() {
                if (!productDetailQuantity || !productDetailTotalPrice) return;
                const quantity = parseInt(productDetailQuantity.textContent) || 1;
                const total = currentProductPrice * quantity;
                productDetailTotalPrice.textContent = `${total.toFixed(2)} CZK`;
            }

            // Quantity controls
            if (productDetailQuantityMinus) {
                productDetailQuantityMinus.addEventListener('click', function() {
                    const currentQty = parseInt(productDetailQuantity.textContent) || 1;
                    if (currentQty > 1) {
                        productDetailQuantity.textContent = currentQty - 1;
                        updateProductDetailTotal();
                    }
                });
            }

            if (productDetailQuantityPlus) {
                productDetailQuantityPlus.addEventListener('click', function() {
                    const currentQty = parseInt(productDetailQuantity.textContent) || 1;
                    productDetailQuantity.textContent = currentQty + 1;
                    updateProductDetailTotal();
                });
            }

            // Function to initialize quantity from cart
            function initializeProductDetailQuantity(productName) {
                if (!productDetailQuantity) return;
                const cartItem = cart.find(item => item.name === productName);
                const initialQuantity = cartItem ? cartItem.quantity : 1;
                productDetailQuantity.textContent = initialQuantity;
                updateProductDetailTotal();
                updateAddToCartButton(productName);
            }
            
            // Make function available globally for updateCartDisplay
            window.initializeProductDetailQuantity = initializeProductDetailQuantity;
            window.updateAddToCartButton = updateAddToCartButton;
            window.updateProductDetailTotal = updateProductDetailTotal;

            // Function to update coffee price based on selected volume
            function updateCoffeePriceByVolume() {
                if (!window.currentCoffeeProduct) return;
                
                const volumeSelect = document.getElementById('coffee-volume-select');
                if (!volumeSelect) return;
                
                const selectedVolume = parseInt(volumeSelect.value) || 250;
                const pricePer100g = window.currentCoffeeProduct.pricePer100g;
                const newPrice = (pricePer100g * selectedVolume) / 100;
                
                currentProductPrice = newPrice;
                
                // Update total price
                updateProductDetailTotal();
            }
            
            // Add event listener for volume selector
            const volumeSelect = document.getElementById('coffee-volume-select');
            if (volumeSelect) {
                volumeSelect.addEventListener('change', function() {
                    updateCoffeePriceByVolume();
                });
            }

            // Function to update Add to Cart button
            function updateAddToCartButton(productName) {
                if (!productDetailAddCart) return;
                // For coffee products, check with volume in name
                let searchName = productName;
                if (window.currentCoffeeProduct) {
                    const volumeSelect = document.getElementById('coffee-volume-select');
                    if (volumeSelect) {
                        const selectedVolume = parseInt(volumeSelect.value) || 250;
                        searchName = `${productName} (${selectedVolume}g)`;
                    }
                }
                const cartItem = cart.find(item => item.name === searchName || item.name.startsWith(productName));
                if (cartItem && cartItem.quantity > 0) {
                    productDetailAddCart.classList.add('in-cart');
                    productDetailAddCart.textContent = `In CaRt (${cartItem.quantity}) âœ“`;
                } else {
                    productDetailAddCart.classList.remove('in-cart');
                    productDetailAddCart.textContent = '+ CaRt';
                }
            }

            // Add to cart from detail modal with selected quantity
            if (productDetailAddCart) {
                productDetailAddCart.addEventListener('click', function(e) {
                    e.stopPropagation();
                    let name = productDetailName.textContent;
                    const price = currentProductPrice;
                    const image = productDetailImage.src;
                    const quantity = parseInt(productDetailQuantity.textContent) || 1;

                    if (!name || isNaN(price) || !image) {
                        console.error('Missing product data!');
                        return;
                    }

                    // For coffee products, include volume in the name
                    if (window.currentCoffeeProduct) {
                        const volumeSelect = document.getElementById('coffee-volume-select');
                        if (volumeSelect) {
                            const selectedVolume = parseInt(volumeSelect.value) || 250;
                            name = `${name} (${selectedVolume}g)`;
                        }
                    }

                    // Check if item already in cart
                    const existingItem = cart.find(item => item.name === name);
                    if (existingItem) {
                        existingItem.quantity = quantity; // Set to selected quantity
                    } else {
                        cart.push({ name, price, image, quantity });
                    }

                    saveCart();
                    updateCartDisplay();
                    
                    // Update button states
                    if (typeof window.updateButtonStates === 'function') {
                        window.updateButtonStates();
                    }
                    
                    // Update add to cart button
                    updateAddToCartButton(name);
                    
                    // Close product detail modal first
                    closeProductDetail();
                    
                    // Open cart sidebar
                    const cartSidebar = document.getElementById('cart-sidebar');
                    const cartOverlay = document.getElementById('cart-overlay');
                    if (cartSidebar && cartOverlay) {
                        cartSidebar.classList.add('open');
                        cartOverlay.classList.add('active');
                    }
                });
            }

            // Close on Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && productDetailModal.classList.contains('open')) {
                    closeProductDetail();
                }
            });
        });
        </script>




        <div id="products-container">
            <!-- COFFEE Category -->
            <div class="category-section" data-category="coffee">
                <h2 class="category-section-heading">SPECIALTY COFFEE</h2>
                <p class="category-subheading">Wake up and smell the deliciousness! We use specialty coffee beans sourced from the finest roasteries around Europe. We do light roasts only, because coffee is a fruit and it's supposed to taste like it. Fuel your art browsing.</p>
                <div class="products-scroll" id="coffee-products-container">
                    <!-- Coffee products will be dynamically loaded here -->
                </div>
            </div>

            <!-- FASHION Category -->
            <div class="category-section" data-category="fashion">
                <h2 class="category-section-heading">FASHION</h2>
                <p class="category-subheading">Look fly, do good. We got independent fashion brands from local designers and collectors. If you know, you know. Dress to impress, support the hustle.</p>
                <div id="fashion-products-container">
                    <!-- Fashion products will be dynamically loaded here -->
                </div>
            </div>

            <!-- ARTS Category -->
            <div class="category-section" data-category="arts">
                <h2 class="category-section-heading">ARTS</h2>
                <p class="category-subheading">Art by the illest. Straight from the local scene, featuring rising artists. Cop something fresh for your walls and support the movement.</p>
                <div class="arts-gallery" id="arts-products-container">
                    <!-- Arts products will be dynamically loaded here -->
                </div>
            </div>

            <!-- CRAFTS Category -->
            <div class="category-section" data-category="crafts">
                <h2 class="category-section-heading">CRAFTS</h2>
                <p class="category-subheading">Handmade heat. Accessories, jewelry, and all that handy stuff, crafted by the best. Find that unique piece that'll make you stand out.</p>
                <div id="crafts-products-container">
                    <!-- Crafts products will be dynamically loaded here -->
                </div>
            </div>

            <!-- MUSIC Category -->
            <div class="category-section" data-category="music">
                <h2 class="category-section-heading">MUSIC</h2>
                <p class="category-subheading">For the music heads. Records and digital drops from the homies, for the homies. Support the artists who keep it authentic and let the vibes hit.</p>
                <div class="products-scroll music-products" id="music-products-container">
                    <!-- Music products will be dynamically loaded here -->
                </div>
            </div>
        </div>
        <div id="footer">
            <b>&copy; 2000s CafÃ© E-Shop // oPEN U</b><br>
            <img src="https://www.gifss.com/computer/computer22.gif" width="24" alt="old gif animation">
            Designed by <b>YourCafeCrew</b> <br>
            <span style="font-size:0.9em;color:#f64b23;">Best viewed in oPen U browser or Netscape 4.7!!</span>
        </div>
    </div>
    <center>
    <table border="5" bgcolor="#fffbe0" cellpadding="8" cellspacing="2" style="margin-top:28px;border-color:#7ca0c7;max-width:100%;width:100%;box-sizing:border-box;">
      <tr>
        <th style="padding:8px;">oPen U tip:</th>
        <td style="padding:8px;">U can click any <span style='color:#24528b;font-weight:bold'>AdD tO CaRt</span> to add 2 ur basket ðŸ‘¾</td>
      </tr>
    </table>
    </center>
    <br>
    <center>
      <img src="https://web.archive.org/web/20090823211950/http://geocities.com/Heartland/Woods/7612/cafecup.gif" alt="coffee gif" width="44">
      <img src="https://web.archive.org/web/20091027124005/http://geocities.com/moonlitemermaid/coffee01.gif" alt="coffee gif2" width="44">
    </center>

    <!-- Cart Sidebar -->
    <div id="cart-sidebar">
        <div id="cart-header">
            <h2>ðŸ›’ Ur CaRt ðŸ›’</h2>
            <button id="cart-close">âœ•</button>
        </div>
        <div id="cart-content">
            <div id="cart-items"></div>
            <div id="cart-empty" style="text-align:center;padding:40px 20px;color:#666;">
                <p>Ur caRt iS eMpTy! ðŸ˜¢</p>
                <p style="font-size:0.9em;">Add sum stuff 2 get started!</p>
            </div>
        </div>
        <div id="cart-footer">
            <div id="cart-total">
                <b>ToTaL: $<span id="cart-total-amount">0.00</span></b>
            </div>
            <button id="cart-checkout">ChEcK OuT ðŸš€</button>
            <button id="cart-clear">ClEaR CaRt</button>
        </div>
    </div>
    <div id="cart-overlay"></div>

    <!-- Product Detail Modal -->
    <div id="product-detail-modal">
        <div id="product-detail-content">
            <div id="product-detail-close-wrapper">
                <button id="product-detail-close">âœ•</button>
            </div>
            <div id="product-detail-body">
                <h2 id="product-detail-name" style="display: none;"></h2>
                <div id="product-detail-envelope">
                    <div id="product-detail-image-section">
                        <div id="product-detail-image-container">
                            <img id="product-detail-image" src="" alt="">
                        </div>
                        <div id="product-detail-quantity-tag">
                            <!-- Price Row - Big and Important -->
                            
                            <!-- Volume and Quantity Row -->
                            <div id="coffee-volume-selector-container" class="product-detail-volume-quantity-row" style="display: none;">
                                <div class="volume-section">
                                    <label for="coffee-volume-select" class="volume-label">VoLuMe:</label>
                                    <select id="coffee-volume-select" class="volume-select">
                                        <option value="250">250g</option>
                                        <option value="500">500g</option>
                                        <option value="1000">1kg</option>
                                    </select>
                                </div>
                                <div class="product-detail-quantity-controls">
                                    <button id="product-detail-quantity-minus" class="quantity-btn">âˆ’</button>
                                    <span id="product-detail-quantity" class="quantity-counter">1</span>
                                    <button id="product-detail-quantity-plus" class="quantity-btn">+</button>
                                </div>
                            </div>
                            
                            <!-- Total Price Row -->
                            <div class="product-detail-total-price-row">
                                <div class="total-price-label">ToTaL PrIcE</div>
                                <div id="product-detail-total-price" class="total-price-value"></div>
                            </div>
                            
                            <!-- Add to Cart Button -->
                            <div class="product-detail-cart-button-row">
                                <button id="product-detail-add-cart" class="add-to-cart-detail coffee-detail-add-cart-btn">+ CaRt</button>
                            </div>
                        </div>
                    </div>
                    <div id="product-detail-table-section">
                        <!-- Coffee Details Table -->
                        <table id="coffee-details-table" class="coffee-details-table" style="display:none;">
                        <tr>
                            <td class="coffee-table-label">OrIgIn</td>
                            <td class="coffee-table-value" id="coffee-origin">-</td>
                        </tr>
                        <tr>
                            <td class="coffee-table-label">ReGiOn</td>
                            <td class="coffee-table-value" id="coffee-region">-</td>
                        </tr>
                        <tr>
                            <td class="coffee-table-label">FaRmEr</td>
                            <td class="coffee-table-value" id="coffee-farmer">-</td>
                        </tr>
                        <tr>
                            <td class="coffee-table-label">RoAsTeRy</td>
                            <td class="coffee-table-value" id="coffee-roastery">-</td>
                        </tr>
                        <tr>
                            <td class="coffee-table-label">VaRiEtY</td>
                            <td class="coffee-table-value" id="coffee-variety">-</td>
                        </tr>
                        <tr>
                            <td class="coffee-table-label">PrOcEsS</td>
                            <td class="coffee-table-value" id="coffee-process">-</td>
                        </tr>
                        <tr>
                            <td class="coffee-table-label">RoAsT TyPe</td>
                            <td class="coffee-table-value" id="coffee-roast-type">-</td>
                        </tr>
                        <tr>
                            <td class="coffee-table-label">RoAsT LeVeL</td>
                            <td class="coffee-table-value" id="coffee-roast-level">-</td>
                        </tr>
                        <tr>
                            <td class="coffee-table-label">FlAvOuR PrOfIlE</td>
                            <td class="coffee-table-value" id="coffee-flavour">-</td>
                        </tr>
                        <tr>
                            <td class="coffee-table-label">BrEwInG MeThOd</td>
                            <td class="coffee-table-value" id="coffee-brewing">-</td>
                        </tr>
                    </table>
                    </div>
                </div>
                <p id="product-detail-description" style="display:none;"></p>
                
                <!-- About Coffee -->
                <div id="coffee-about-section" class="coffee-about-section" style="display:none;">
                    <h3>AbOuT CoFfEe</h3>
                    <div id="coffee-about-coffee"></div>
                </div>
                
                <!-- About Farmer -->
                <div id="coffee-farmer-section" class="coffee-about-section" style="display:none;">
                    <h3>AbOuT FaRmEr</h3>
                    <div id="coffee-about-farmer"></div>
                </div>
                
                <!-- About Roastery -->
                <div id="coffee-roastery-section" class="coffee-about-section" style="display:none;">
                    <h3>AbOuT RoAsTeRy</h3>
                    <div id="coffee-about-roastery"></div>
                </div>
            </div>
        </div>
    </div>
    <div id="product-detail-overlay"></div>
    
    <!-- Admin Panel -->
    <div id="admin-panel">
        <div id="admin-header">
            <h2>ðŸ”§ PrOdUcT AdMiN ðŸ”§</h2>
            <button id="admin-close">âœ•</button>
        </div>
        <div id="admin-content">
            <div id="admin-category-selector">
                <h3>SeLeCt CaTeGoRy:</h3>
                <div class="admin-category-buttons">
                    <button class="admin-category-btn active" data-category="coffee">â˜• CoFfEe</button>
                    <button class="admin-category-btn" data-category="music">ðŸŽµ MuSiC</button>
                    <button class="admin-category-btn" data-category="fashion">ðŸ‘• FaShIoN</button>
                    <button class="admin-category-btn" data-category="arts">ðŸŽ¨ ArTs</button>
                    <button class="admin-category-btn" data-category="crafts">âœ‚ï¸ CrAfTs</button>
                </div>
            </div>
            <div id="admin-form-section">
                <h3 id="admin-form-title">âž• AdD nEw PrOdUcT</h3>
                <form id="admin-product-form">
                    <div class="admin-form-group">
                        <label>PrOdUcT nAmE:</label>
                        <input type="text" id="admin-name" required placeholder="Product name">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>ðŸ“· PrOdUcT iMaGe:</label>
                        <input type="file" id="admin-image-file" accept="image/*">
                        <div id="admin-image-preview" style="margin-top:10px;display:none;">
                            <img id="admin-preview-img" style="max-width:200px;max-height:200px;border:2px solid #7ca0c7;border-radius:4px;">
                        </div>
                        <div style="margin-top:10px;font-size:0.9em;color:#666;">Or use image URL:</div>
                        <input type="url" id="admin-image-url" placeholder="https://... (optional if uploading file)">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>DeScRiPtIoN:</label>
                        <input type="text" id="admin-description" placeholder="Short description">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>PrIcE (CZK):</label>
                        <input type="number" id="admin-price" step="1" required placeholder="e.g., 480" min="0">
                    </div>
                    
                    <!-- Coffee specific fields -->
                    <div class="admin-category-fields" data-category="coffee">
                    <div class="admin-form-group">
                        <label>RoAsTeRy:</label>
                        <input type="text" id="admin-roastery" placeholder="e.g., BeBerry Coffee">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>CoFfEe OrIgIn:</label>
                        <input type="text" id="admin-origin" placeholder="e.g., Honduras">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>ReGiOn:</label>
                        <input type="text" id="admin-region" placeholder="e.g., El Paraiso">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>VaRiEtY:</label>
                        <input type="text" id="admin-variety" placeholder="e.g., Yellow Catuai">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>RoAsT TyPe:</label>
                        <input type="text" id="admin-roast-type" placeholder="e.g., Espresso">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>PrOcEsS:</label>
                        <input type="text" id="admin-process" placeholder="e.g., Natural">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>FlAvOuR PrOfIlE:</label>
                        <input type="text" id="admin-flavour" placeholder="e.g., Milk chocolate, Cashew, Dried cranberries">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>RoAsT LeVeL:</label>
                        <input type="text" id="admin-roast-level" placeholder="e.g., Light Roast">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>BrEwInG MeThOd:</label>
                        <input type="text" id="admin-brewing" placeholder="e.g., Espresso">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>PaCkAgE SiZe:</label>
                        <input type="text" id="admin-package-size" placeholder="e.g., 250g">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>AbOuT CoFfEe (detailed description):</label>
                        <textarea id="admin-about-coffee" rows="6" placeholder="e.g., To find the origin of this festive lot, we travel to the Colombian region of Risaralda..."></textarea>
                    </div>
                    
                    <div class="admin-form-group">
                        <label>AbOuT RoAsTeRy:</label>
                        <textarea id="admin-about-roastery" rows="6" placeholder="e.g., BeBerry Coffee is Czech roastery founded by Thomas Laca..."></textarea>
                    </div>
                    
                    <div class="admin-form-group">
                        <label>AlTiTuDe:</label>
                        <input type="text" id="admin-altitude" placeholder="e.g., 1,400 meters above sea level">
                    </div>
                    
                    <div class="admin-form-group">
                        <label>PrOcEsSiNg StAtIoN:</label>
                        <input type="text" id="admin-processing-station" placeholder="e.g., Finca Milan">
                        </div>
                    </div>
                    
                    <!-- Music specific fields -->
                    <div class="admin-category-fields" data-category="music">
                        <div class="admin-form-group">
                            <label>TrAcK TiTlE (official name, correct spelling):</label>
                            <input type="text" id="admin-track-title" placeholder="e.g., Bohemian Rhapsody">
                            <small style="color:#666;font-size:0.85em;">Official track name with correct spelling</small>
                        </div>
                        
                        <div class="admin-form-group">
                            <label>ArTiSt NaMe(s) (main artist):</label>
                            <input type="text" id="admin-artist-name" name="admin-artist-name" placeholder="e.g., Queen">
                        </div>
                        
                        <div class="admin-form-group">
                            <label>FeAtUrEd ArTiSt(s) (if any):</label>
                            <input type="text" id="admin-featured-artists" placeholder="e.g., David Bowie">
                            <small style="color:#666;font-size:0.85em;">Separate multiple artists with commas</small>
                        </div>
                        
                        <div class="admin-form-group">
                            <label>ReLeAsE DaTe:</label>
                            <input type="date" id="admin-release-date">
                        </div>
                        
                        <div class="admin-form-group">
                            <label>ReCoRd LaBeL:</label>
                            <input type="text" id="admin-record-label" placeholder="e.g., EMI Records">
                            <small style="color:#666;font-size:0.85em;">Or mark as "Independent" or "Self-released"</small>
                        </div>
                        
                        <div class="admin-form-group">
                            <label>GeNrE:</label>
                            <input type="text" id="admin-genre" placeholder="e.g., Rock">
                        </div>
                        
                        <div class="admin-form-group">
                            <label>SuBgEnRe:</label>
                            <input type="text" id="admin-subgenre" placeholder="e.g., Progressive Rock">
                        </div>
                        
                        <div class="admin-form-group">
                            <label>TrAcK DeScRiPtIoN / MoOd / StOrY:</label>
                            <textarea id="admin-track-description" rows="5" placeholder="Describe the track's mood, story, or any relevant information..."></textarea>
                        </div>
                        
                        <div class="admin-form-group">
                            <label>KeYwOrDs / TaGs:</label>
                            <input type="text" id="admin-keywords" placeholder="e.g., epic, ballad, classic, 70s">
                            <small style="color:#666;font-size:0.85em;">Separate keywords with commas</small>
                        </div>
                        
                        <div class="admin-form-group">
                            <label>ðŸŽµ MuSiC SoUrCe:</label>
                            <div style="margin-top:10px;">
                                <label style="display:inline-block;margin-right:20px;">
                                    <input type="radio" name="music-source" value="youtube" checked> YouTube
                                </label>
                                <label style="display:inline-block;margin-right:20px;">
                                    <input type="radio" name="music-source" value="soundcloud"> SoUnDcLoUd
                                </label>
                                <label style="display:inline-block;">
                                    <input type="radio" name="music-source" value="upload"> Upload Own Music
                                </label>
                            </div>
                        </div>
                        
                        <div id="music-youtube-section">
                            <div class="admin-form-group">
                                <label>YoUtUbE ViDeO Id:</label>
                                <input type="text" id="admin-youtube-id" placeholder="e.g., dQw4w9WgXcQ">
                                <small style="color:#666;font-size:0.85em;">Only the video ID from YouTube URL (e.g., from https://www.youtube.com/watch?v=dQw4w9WgXcQ)</small>
                            </div>
                        </div>
                        
                        <div id="music-soundcloud-section" style="display:none;">
                            <div class="admin-form-group">
                                <label>SoUnDcLoUd TrAcK UrL:</label>
                                <input type="text" id="admin-soundcloud-url" placeholder="e.g., https://soundcloud.com/user/track-name">
                                <small style="color:#666;font-size:0.85em;">Full SoundCloud track URL (e.g., https://soundcloud.com/artist/track-name)</small>
                            </div>
                        </div>
                        
                        <div id="music-upload-section" style="display:none;">
                            <div class="admin-form-group">
                                <label>ðŸ“ UpLoAd MuSiC FiLe:</label>
                                <input type="file" id="admin-music-file" accept="audio/*">
                                <small style="color:#666;font-size:0.85em;">Supported formats: MP3, WAV, OGG, M4A, AAC</small>
                                <div id="admin-music-preview" style="margin-top:10px;display:none;">
                                    <audio id="admin-preview-audio" controls style="width:100%;max-width:400px;"></audio>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="admin-form-actions">
                        <button type="submit" id="admin-submit">AdD PrOdUcT</button>
                        <button type="button" id="admin-cancel-edit" style="display:none;">CaNcEl EdIt</button>
                    </div>
                </form>
            </div>
            <div id="admin-products-list">
                <h3>ðŸ“‹ ExIsTiNg PrOdUcTs</h3>
                <div id="admin-products-container"></div>
            </div>
        </div>
    </div>
    <div id="admin-overlay"></div>
    
    <script>
        // Snowing effect with bigger rectangular snowflakes
        document.addEventListener('DOMContentLoaded', function() {
            const snowContainer = document.createElement('div');
            snowContainer.id = 'snow-container';
            snowContainer.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; overflow: hidden;';
            document.body.appendChild(snowContainer);
            
            const snowflakes = [];
            const snowflakeCount = 30;
            
            function createSnowflake() {
                const snowflake = document.createElement('div');
                const size = Math.random() * 8 + 6; // 6-14px size for bigger flakes
                const startX = Math.random() * window.innerWidth;
                const fallSpeed = Math.random() * 2 + 1; // 1-3px per frame
                const sway = Math.random() * 2 - 1; // -1 to 1 for horizontal movement
                
                snowflake.style.cssText = `
                    position: absolute;
                    width: ${size}px;
                    height: ${size * 1.5}px;
                    background: rgba(255, 255, 255, 0.8);
                    border: 1px solid rgba(255, 255, 255, 0.9);
                    top: -20px;
                    left: ${startX}px;
                    pointer-events: none;
                    box-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
                `;
                
                snowContainer.appendChild(snowflake);
                
                return {
                    element: snowflake,
                    x: startX,
                    y: -20,
                    speed: fallSpeed,
                    sway: sway,
                    size: size
                };
            }
            
            // Create initial snowflakes
            for (let i = 0; i < snowflakeCount; i++) {
                const flake = createSnowflake();
                flake.y = Math.random() * window.innerHeight; // Start at random heights
                flake.element.style.top = flake.y + 'px';
                snowflakes.push(flake);
            }
            
            function animateSnow() {
                snowflakes.forEach(flake => {
                    // Move down
                    flake.y += flake.speed;
                    
                    // Add slight horizontal sway
                    flake.x += Math.sin(flake.y * 0.01) * flake.sway;
                    
                    // Reset if off screen
                    if (flake.y > window.innerHeight) {
                        flake.y = -20;
                        flake.x = Math.random() * window.innerWidth;
                    }
                    
                    // Keep within horizontal bounds
                    if (flake.x < 0) flake.x = window.innerWidth;
                    if (flake.x > window.innerWidth) flake.x = 0;
                    
                    // Update position
                    flake.element.style.top = flake.y + 'px';
                    flake.element.style.left = flake.x + 'px';
                });
                
                requestAnimationFrame(animateSnow);
            }
            
            // Handle window resize
            window.addEventListener('resize', function() {
                snowflakes.forEach(flake => {
                    if (flake.x > window.innerWidth) {
                        flake.x = window.innerWidth;
                    }
                });
            });
            
            animateSnow();
        });
    </script>
    
    <script>
        // Parallax effect for background
        document.addEventListener('DOMContentLoaded', function() {
            let ticking = false;
            
            function updateParallax() {
                const scrolled = window.pageYOffset || document.documentElement.scrollTop;
                // Move background at 9% of scroll speed for slower parallax effect
                const parallaxSpeed = 0.09;
                const yPos = -(scrolled * parallaxSpeed);
                
                // Apply transform directly via style element
                let style = document.getElementById('parallax-style');
                if (!style) {
                    style = document.createElement('style');
                    style.id = 'parallax-style';
                    document.head.appendChild(style);
                }
                style.textContent = `body::before { transform: translateY(${yPos}px); }`;
                
                ticking = false;
            }
            
            function requestTick() {
                if (!ticking) {
                    window.requestAnimationFrame(updateParallax);
                    ticking = true;
                }
            }
            
            window.addEventListener('scroll', requestTick, { passive: true });
            updateParallax(); // Initial call
        });
    </script>
    
    <script>
        // Arts Gallery - Chaotic positioning
        document.addEventListener('DOMContentLoaded', function() {
            const artFrames = document.querySelectorAll('.art-frame');
            if (artFrames.length === 0) return;
            
            // More chaotic rotations and positions for disorganized gallery
            artFrames.forEach((frame, index) => {
                // Random rotation between -10.5 and +10.5 degrees (30% less than -15 to +15)
                const rotation = (Math.random() * 21) - 10.5;
                
                // Random slight position offset for more chaos (also 30% less)
                const offsetX = (Math.random() * 28) - 14; // -14px to +14px (30% less)
                const offsetY = (Math.random() * 28) - 14; // -14px to +14px (30% less)
                
                // Apply random rotation and position
                frame.style.transform = `rotate(${rotation}deg) translate(${offsetX}px, ${offsetY}px)`;
                frame.style.margin = '0';
            });
            
            // Make art frames clickable for product detail
            artFrames.forEach(frame => {
                frame.addEventListener('click', function(e) {
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }
                    
                    const name = this.getAttribute('data-name');
                    const price = this.getAttribute('data-price');
                    const image = this.getAttribute('data-image');
                    const short = this.getAttribute('data-short');
                    const description = this.getAttribute('data-description');
                    
                    if (name && price && image) {
                        // Find the openProductDetail function from the product detail modal script
                        const productDetailScript = document.querySelector('script');
                        // Try to call it if it exists in global scope
                        if (window.openProductDetail) {
                            window.openProductDetail(name, price, image, short, description);
                        } else {
                            // Fallback: trigger click on the button to add to cart
                            const button = this.querySelector('.add-to-cart');
                            if (button) button.click();
                        }
                    }
                });
            });
        });
    </script>
    
    <!-- Arts Gallery positioning is now handled in renderArtsProducts function -->
    
    <script>
        // Coffee Products Management System
        (function() {
            // Default coffee products (used on first load) - simplified for backward compatibility
            const defaultCoffeeProducts = [
                { 
                    name: "BeBeRrY CoFfEe #1", 
                    description: "Premium specialty coffee", 
                    price: 480, 
                    image: "product_media/coffee_beans/beberry_1.png",
                    roastery: "BeBerry Coffee",
                    origin: "Honduras",
                    region: "El Paraiso",
                    variety: "Yellow Catuai",
                    roastType: "Espresso Roast",
                    process: "Natural",
                    flavour: "Milk chocolate, Cashews",
                    roastLevel: "Light to Medium",
                    brewing: "Espresso",
                    packageSize: "250g",
                    aboutCoffee: "To find the origin of this festive lot, we travel to the Colombian region of Risaralda, where the Finca Milan farm is located. The local farming team is dedicated to growing the Caturra variety at an altitude of around 1,400 meters above sea level, where coffee trees thrive in an ideal climate. Finca Milan is known for its emphasis on innovative processing and deep respect for nature and the soil, which produces beans with a unique character. The processing method for this festive coffee is truly special. Panettone is the result of a precise co-fermentation process, in which freshly harvested coffee cherries were fermented together with orange and cardamom. This approach allows the beans to absorb delicate fruity and spicy tones, which later blossom in the cup. The coffee was then processed using the honey method â€“ that is, hulled, but with part of the pulp left on during drying. This helped to emphasize its natural sweetness and smoothness. The result is a richly layered flavor profile that combines joy, warmth, and elegance â€“ exactly what you expect from a festive coffee. Altitude: 1,400 meters above sea level Processing station: Finca Milan",
                    aboutRoastery: "BeBerry Coffee is Czech roastery founded by Thomas Laca, known in the coffee world as Q Grader, a course lecturer, barista and coffee taster. Thomas became interested in specialty coffee while studying at the University of Economics in Prague. He gained most of his experience in the Polish roastery, where he worked under the guidance of international jurors and Q Grader, and after returning to Prague as a QC manager of green and roasted coffee in the roastery. Now he has decided to use all his experience and knowledge and establish his own roastery. Thomas and the team select only the best coffee beans for you and their goal is to introduce you to the coffee as it really is - pleasantly fruity. In BeBerry Coffee, Tom's girlfriend Karin is also the biggest support, who has just become the recent Slovak Champion in Cup Tasting 2021.",
                    altitude: "1,400 meters above sea level",
                    processingStation: "Finca Milan"
                },
                { 
                    name: "BeBeRrY CoFfEe #2", 
                    description: "Premium specialty coffee", 
                    price: 480, 
                    image: "product_media/coffee_beans/beberry_2.png",
                    roastery: "BeBerry Coffee",
                    origin: "Honduras",
                    region: "El Paraiso",
                    variety: "Yellow Catuai",
                    roastType: "Espresso Roast",
                    process: "Natural",
                    flavour: "Milk chocolate, Cashews",
                    roastLevel: "Light to Medium",
                    brewing: "Espresso",
                    packageSize: "250g",
                    aboutCoffee: "To find the origin of this festive lot, we travel to the Colombian region of Risaralda, where the Finca Milan farm is located. The local farming team is dedicated to growing the Caturra variety at an altitude of around 1,400 meters above sea level, where coffee trees thrive in an ideal climate. Finca Milan is known for its emphasis on innovative processing and deep respect for nature and the soil, which produces beans with a unique character. The processing method for this festive coffee is truly special. Panettone is the result of a precise co-fermentation process, in which freshly harvested coffee cherries were fermented together with orange and cardamom. This approach allows the beans to absorb delicate fruity and spicy tones, which later blossom in the cup. The coffee was then processed using the honey method â€“ that is, hulled, but with part of the pulp left on during drying. This helped to emphasize its natural sweetness and smoothness. The result is a richly layered flavor profile that combines joy, warmth, and elegance â€“ exactly what you expect from a festive coffee. Altitude: 1,400 meters above sea level Processing station: Finca Milan",
                    aboutRoastery: "BeBerry Coffee is Czech roastery founded by Thomas Laca, known in the coffee world as Q Grader, a course lecturer, barista and coffee taster. Thomas became interested in specialty coffee while studying at the University of Economics in Prague. He gained most of his experience in the Polish roastery, where he worked under the guidance of international jurors and Q Grader, and after returning to Prague as a QC manager of green and roasted coffee in the roastery. Now he has decided to use all his experience and knowledge and establish his own roastery. Thomas and the team select only the best coffee beans for you and their goal is to introduce you to the coffee as it really is - pleasantly fruity. In BeBerry Coffee, Tom's girlfriend Karin is also the biggest support, who has just become the recent Slovak Champion in Cup Tasting 2021.",
                    altitude: "1,400 meters above sea level",
                    processingStation: "Finca Milan"
                },
                { 
                    name: "BeBeRrY CoFfEe #3", 
                    description: "Premium specialty coffee", 
                    price: 480, 
                    image: "product_media/coffee_beans/beberry_3.jpg",
                    roastery: "BeBerry Coffee",
                    origin: "Honduras",
                    region: "El Paraiso",
                    variety: "Yellow Catuai",
                    roastType: "Espresso Roast",
                    process: "Natural",
                    flavour: "Milk chocolate, Cashews",
                    roastLevel: "Light to Medium",
                    brewing: "Espresso",
                    packageSize: "250g",
                    aboutCoffee: "To find the origin of this festive lot, we travel to the Colombian region of Risaralda, where the Finca Milan farm is located. The local farming team is dedicated to growing the Caturra variety at an altitude of around 1,400 meters above sea level, where coffee trees thrive in an ideal climate. Finca Milan is known for its emphasis on innovative processing and deep respect for nature and the soil, which produces beans with a unique character. The processing method for this festive coffee is truly special. Panettone is the result of a precise co-fermentation process, in which freshly harvested coffee cherries were fermented together with orange and cardamom. This approach allows the beans to absorb delicate fruity and spicy tones, which later blossom in the cup. The coffee was then processed using the honey method â€“ that is, hulled, but with part of the pulp left on during drying. This helped to emphasize its natural sweetness and smoothness. The result is a richly layered flavor profile that combines joy, warmth, and elegance â€“ exactly what you expect from a festive coffee. Altitude: 1,400 meters above sea level Processing station: Finca Milan",
                    aboutRoastery: "BeBerry Coffee is Czech roastery founded by Thomas Laca, known in the coffee world as Q Grader, a course lecturer, barista and coffee taster. Thomas became interested in specialty coffee while studying at the University of Economics in Prague. He gained most of his experience in the Polish roastery, where he worked under the guidance of international jurors and Q Grader, and after returning to Prague as a QC manager of green and roasted coffee in the roastery. Now he has decided to use all his experience and knowledge and establish his own roastery. Thomas and the team select only the best coffee beans for you and their goal is to introduce you to the coffee as it really is - pleasantly fruity. In BeBerry Coffee, Tom's girlfriend Karin is also the biggest support, who has just become the recent Slovak Champion in Cup Tasting 2021.",
                    altitude: "1,400 meters above sea level",
                    processingStation: "Finca Milan"
                },
                { 
                    name: "BeBeRrY SpEcIaL", 
                    description: "Premium specialty coffee", 
                    price: 520, 
                    image: "product_media/coffee_beans/beberry_special.png",
                    roastery: "BeBerry Coffee",
                    origin: "Honduras",
                    region: "El Paraiso",
                    variety: "Yellow Catuai",
                    roastType: "Espresso Roast",
                    process: "Natural",
                    flavour: "Milk chocolate, Cashews",
                    roastLevel: "Light to Medium",
                    brewing: "Espresso",
                    packageSize: "250g",
                    aboutCoffee: "To find the origin of this festive lot, we travel to the Colombian region of Risaralda, where the Finca Milan farm is located. The local farming team is dedicated to growing the Caturra variety at an altitude of around 1,400 meters above sea level, where coffee trees thrive in an ideal climate. Finca Milan is known for its emphasis on innovative processing and deep respect for nature and the soil, which produces beans with a unique character. The processing method for this festive coffee is truly special. Panettone is the result of a precise co-fermentation process, in which freshly harvested coffee cherries were fermented together with orange and cardamom. This approach allows the beans to absorb delicate fruity and spicy tones, which later blossom in the cup. The coffee was then processed using the honey method â€“ that is, hulled, but with part of the pulp left on during drying. This helped to emphasize its natural sweetness and smoothness. The result is a richly layered flavor profile that combines joy, warmth, and elegance â€“ exactly what you expect from a festive coffee. Altitude: 1,400 meters above sea level Processing station: Finca Milan",
                    aboutRoastery: "BeBerry Coffee is Czech roastery founded by Thomas Laca, known in the coffee world as Q Grader, a course lecturer, barista and coffee taster. Thomas became interested in specialty coffee while studying at the University of Economics in Prague. He gained most of his experience in the Polish roastery, where he worked under the guidance of international jurors and Q Grader, and after returning to Prague as a QC manager of green and roasted coffee in the roastery. Now he has decided to use all his experience and knowledge and establish his own roastery. Thomas and the team select only the best coffee beans for you and their goal is to introduce you to the coffee as it really is - pleasantly fruity. In BeBerry Coffee, Tom's girlfriend Karin is also the biggest support, who has just become the recent Slovak Champion in Cup Tasting 2021.",
                    altitude: "1,400 meters above sea level",
                    processingStation: "Finca Milan"
                },
                { 
                    name: "BeBeRrY CoFfEe #4", 
                    description: "Premium specialty coffee", 
                    price: 480, 
                    image: "product_media/coffee_beans/beberry_1.png",
                    roastery: "BeBerry Coffee",
                    origin: "Honduras",
                    region: "El Paraiso",
                    variety: "Yellow Catuai",
                    roastType: "Espresso Roast",
                    process: "Natural",
                    flavour: "Milk chocolate, Cashews",
                    roastLevel: "Light to Medium",
                    brewing: "Espresso",
                    packageSize: "250g",
                    aboutCoffee: "To find the origin of this festive lot, we travel to the Colombian region of Risaralda, where the Finca Milan farm is located. The local farming team is dedicated to growing the Caturra variety at an altitude of around 1,400 meters above sea level, where coffee trees thrive in an ideal climate. Finca Milan is known for its emphasis on innovative processing and deep respect for nature and the soil, which produces beans with a unique character. The processing method for this festive coffee is truly special. Panettone is the result of a precise co-fermentation process, in which freshly harvested coffee cherries were fermented together with orange and cardamom. This approach allows the beans to absorb delicate fruity and spicy tones, which later blossom in the cup. The coffee was then processed using the honey method â€“ that is, hulled, but with part of the pulp left on during drying. This helped to emphasize its natural sweetness and smoothness. The result is a richly layered flavor profile that combines joy, warmth, and elegance â€“ exactly what you expect from a festive coffee. Altitude: 1,400 meters above sea level Processing station: Finca Milan",
                    aboutRoastery: "BeBerry Coffee is Czech roastery founded by Thomas Laca, known in the coffee world as Q Grader, a course lecturer, barista and coffee taster. Thomas became interested in specialty coffee while studying at the University of Economics in Prague. He gained most of his experience in the Polish roastery, where he worked under the guidance of international jurors and Q Grader, and after returning to Prague as a QC manager of green and roasted coffee in the roastery. Now he has decided to use all his experience and knowledge and establish his own roastery. Thomas and the team select only the best coffee beans for you and their goal is to introduce you to the coffee as it really is - pleasantly fruity. In BeBerry Coffee, Tom's girlfriend Karin is also the biggest support, who has just become the recent Slovak Champion in Cup Tasting 2021.",
                    altitude: "1,400 meters above sea level",
                    processingStation: "Finca Milan"
                }
            ];
            
            // Load products from localStorage or use defaults
            function loadCoffeeProducts() {
                // Use the same key as the admin panel for consistency
                const stored = localStorage.getItem('tutuProducts_coffee');
                if (stored) {
                    return JSON.parse(stored);
                }
                // Initialize with defaults if no products exist
                saveCoffeeProducts(defaultCoffeeProducts);
                return defaultCoffeeProducts;
            }
            
            // Save products to localStorage
            function saveCoffeeProducts(products) {
                // Use the same key as the admin panel for consistency
                localStorage.setItem('tutuProducts_coffee', JSON.stringify(products));
            }
            
            // Render coffee products to the page
            async function renderCoffeeProducts() {
                const container = document.getElementById('coffee-products-container');
                if (!container) return;
                
                try {
                    const products = await loadProducts('coffee');
                container.innerHTML = products.map(product => {
                    // Build card info: Origin + Region (main heading), Roastery, Process, Volume, Price
                    const origin = product.origin || '';
                    const region = product.region || '';
                    const originRegion = [origin, region].filter(Boolean).join(' ') || '';
                    const roastery = product.roastery || '';
                    const process = product.process || '';
                    const volume = product.packageSize || '';
                    const price = product.price || 0;
                    
                    // Calculate price for smallest package size (250g) - default
                    const basePackageSize = product.packageSize || '250g';
                    const baseSize = parseInt(basePackageSize.replace(/[^0-9]/g, '')) || 250;
                    const pricePer100g = (price / baseSize) * 100;
                    const smallestSize = 250; // Always use 250g as default
                    const smallestPrice = (pricePer100g * smallestSize) / 100;
                    
                    // Create name with volume suffix (matching detail view format)
                    const cartName = `${product.name} (${smallestSize}g)`;
                    
                    // Price only (no volume in price tag)
                    const priceDisplay = `${price} CZK`;
                    
                    // Store all product data in data attributes for modal
                    const productData = JSON.stringify(product).replace(/"/g, '&quot;');
                    
                    return `
                    <div class="product coffee-product" 
                         data-product-data="${productData}">
                        <img src="${product.image ? (product.image.startsWith('http') ? product.image : (product.image.startsWith('/') ? `http://localhost:3000${product.image}` : product.image)) : ''}" alt="${product.name}">
                        <div class="coffee-card-info">
                            ${originRegion ? `<div class="coffee-main-heading">${originRegion}</div>` : ''}
                            ${roastery ? `<div class="coffee-brand">${roastery}</div>` : ''}
                            ${process ? `<div class="coffee-process">${process}</div>` : ''}
                            ${volume ? `<div class="coffee-package-size">${volume}</div>` : ''}
                            <button class="coffee-add-to-cart-btn" 
                                    data-name="${cartName}" 
                                    data-price="${smallestPrice}" 
                                    data-image="${product.image}"
                                    onclick="event.stopPropagation(); if(typeof window.addToCart === 'function') { window.addToCart('${cartName}', ${smallestPrice}, '${product.image}'); if(typeof window.updateButtonStates === 'function') window.updateButtonStates(); }">+ CaRt</button>
                        </div>
                    </div>
                `;
                }).join('');
                
                // Re-initialize cart buttons after rendering
                if (typeof window.updateButtonStates === 'function') {
                    window.updateButtonStates();
                }
                
                // Re-initialize product click handlers for coffee products using event delegation
                const coffeeContainer = document.getElementById('coffee-products-container');
                if (coffeeContainer) {
                    // Remove any existing listener and add a fresh one
                    const newHandler = function(e) {
                        // Find the closest coffee product
                        const coffeeProduct = e.target.closest('.coffee-product');
                        if (!coffeeProduct) return;
                        
                        // Don't open if clicking the add to cart button
                        if (e.target.closest('.coffee-add-to-cart-btn')) {
                            return;
                        }
                        
                        const productDataStr = coffeeProduct.getAttribute('data-product-data');
                        console.log('Coffee product clicked!', productDataStr ? 'Data found' : 'No data');
                        
                        if (productDataStr) {
                            try {
                                const productData = JSON.parse(productDataStr.replace(/&quot;/g, '"'));
                                console.log('Parsed product data:', productData);
                                
                                if (window.openCoffeeProductDetail) {
                                    window.openCoffeeProductDetail(productData);
                                } else {
                                    console.error('openCoffeeProductDetail function not available');
                                    // Try again after a short delay
                                    setTimeout(function() {
                                        if (window.openCoffeeProductDetail) {
                                            window.openCoffeeProductDetail(productData);
                                        }
                                    }, 100);
                                }
                            } catch (err) {
                                console.error('Error parsing product data:', err, productDataStr);
                            }
                        } else {
                            console.error('No product data found on element', coffeeProduct);
                        }
                    };
                    
                    // Remove old listener if it exists (we'll store it)
                    if (coffeeContainer._coffeeClickHandler) {
                        coffeeContainer.removeEventListener('click', coffeeContainer._coffeeClickHandler);
                    }
                    coffeeContainer._coffeeClickHandler = newHandler;
                    coffeeContainer.addEventListener('click', newHandler, true); // Use capture phase
                    console.log('Coffee click handler attached to container');
                } else {
                    console.error('Coffee container not found!');
                }
                
                // Set cursor pointer on all coffee products
                document.querySelectorAll('#coffee-products-container .coffee-product').forEach(product => {
                    product.style.cursor = 'pointer';
                });
                } catch (error) {
                    console.error('Error rendering coffee products:', error);
                    container.innerHTML = '<p style="text-align:center;color:red;">ErRoR LoAdInG CoFfEe PrOdUcTs. ChEcK CoNsOlE.</p>';
                }
            }
            
            // Admin Panel Functionality
            const adminPanel = document.getElementById('admin-panel');
            const adminOverlay = document.getElementById('admin-overlay');
            const adminToggle = document.getElementById('admin-toggle');
            const adminClose = document.getElementById('admin-close');
            const adminForm = document.getElementById('admin-product-form');
            const adminProductsContainer = document.getElementById('admin-products-container');
            const adminCancelEdit = document.getElementById('admin-cancel-edit');
            const adminFormTitle = document.getElementById('admin-form-title');
            const adminProductsTitle = document.getElementById('admin-products-title');
            
            // Current category and editing state
            let currentCategory = 'coffee';
            let editingIndex = null;
            
            // Category selector functionality
            document.querySelectorAll('.admin-category-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const category = this.getAttribute('data-category');
                    switchCategory(category);
                });
            });
            
            // Switch category
            function switchCategory(category) {
                currentCategory = category;
                
                // Update active button
                document.querySelectorAll('.admin-category-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('data-category') === category) {
                        btn.classList.add('active');
                    }
                });
                
                // Show/hide category-specific fields and disable/enable inputs
                document.querySelectorAll('.admin-category-fields').forEach(field => {
                    const isActive = field.getAttribute('data-category') === category;
                    field.classList.remove('active');
                    if (isActive) {
                        field.classList.add('active');
                        // Enable all inputs in active category
                        field.querySelectorAll('input, textarea, select').forEach(input => {
                            input.disabled = false;
                            input.removeAttribute('required');
                            // Re-add required to artist-name if music category
                            if (category === 'music' && input.id === 'admin-artist-name') {
                                input.setAttribute('required', 'required');
                            }
                        });
                    } else {
                        // Disable all inputs in inactive categories to prevent validation
                        field.querySelectorAll('input, textarea, select').forEach(input => {
                            input.disabled = true;
                            input.removeAttribute('required');
                        });
                    }
                });
                
                // Update titles
                if (adminFormTitle) {
                    adminFormTitle.textContent = `âž• AdD nEw ${category.toUpperCase()} PrOdUcT`;
                }
                if (adminProductsTitle) {
                    adminProductsTitle.textContent = `ðŸ“‹ ExIsTiNg ${category.toUpperCase()} PrOdUcTs`;
                }
                
                // Reset form
                adminForm.reset();
                editingIndex = null;
                window._editingProduct = null; // Clear stored product reference
                document.getElementById('admin-submit').textContent = 'AdD PrOdUcT';
                adminCancelEdit.style.display = 'none';
                document.getElementById('admin-image-preview').style.display = 'none';
                
                // Render products for this category
                renderAdminProductsList();
            }
            
            // Open admin panel
            function openAdminPanel() {
                if (adminPanel) adminPanel.classList.add('open');
                if (adminOverlay) adminOverlay.classList.add('active');
                switchCategory('coffee'); // Start with coffee category
            }
            
            // Close admin panel
            function closeAdminPanel() {
                if (adminPanel) adminPanel.classList.remove('open');
                if (adminOverlay) adminOverlay.classList.remove('active');
                editingIndex = null;
                window._editingProduct = null; // Clear stored product reference
                adminForm.reset();
                document.getElementById('admin-submit').textContent = 'AdD PrOdUcT';
                adminCancelEdit.style.display = 'none';
                document.getElementById('admin-image-preview').style.display = 'none';
            }
            
            // API Configuration
            const API_BASE_URL = 'http://localhost:3000/api';
            
            // Generic product management functions - Now using Backend API
            async function loadProducts(category) {
                try {
                    const response = await fetch(`${API_BASE_URL}/products/${category}`);
                    if (!response.ok) {
                        // If 404, return empty array (no products yet)
                        if (response.status === 404) {
                            console.log(`No products found for category: ${category} (this is normal for new installations)`);
                            return [];
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const products = await response.json();
                    return products || [];
                } catch (error) {
                    // Network errors or other issues - try localStorage fallback
                    console.warn(`API request failed for ${category}, trying localStorage fallback:`, error.message);
                    const stored = localStorage.getItem(`tutuProducts_${category}`);
                    if (stored) {
                        console.warn('Using localStorage fallback');
                        return JSON.parse(stored);
                    }
                    return [];
                }
            }
            
            async function saveProducts(category, products) {
                // This function is kept for compatibility but won't be used directly
                // Products are saved via create/update API endpoints
                console.warn('saveProducts called directly - use create/update endpoints instead');
                return products;
            }
            
            async function createProduct(category, productData) {
                try {
                    console.log('Creating product:', category, productData);
                    const response = await fetch(`${API_BASE_URL}/products/${category}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(productData)
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('API Error Response:', errorText);
                        let errorData;
                        try {
                            errorData = JSON.parse(errorText);
                        } catch (e) {
                            errorData = { error: errorText || 'Failed to create product' };
                        }
                        throw new Error(errorData.error || 'Failed to create product');
                    }
                    const result = await response.json();
                    console.log('Product created successfully:', result);
                    return result;
                } catch (error) {
                    console.error('Error creating product:', error);
                    throw error;
                }
            }
            
            async function updateProduct(category, productId, productData) {
                try {
                    const response = await fetch(`${API_BASE_URL}/products/${category}/${productId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(productData)
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Failed to update product');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Error updating product:', error);
                    throw error;
                }
            }
            
            async function deleteProduct(category, productId) {
                try {
                    const response = await fetch(`${API_BASE_URL}/products/${category}/${productId}`, {
                        method: 'DELETE'
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Failed to delete product');
                    }
                    return await response.json();
                } catch (error) {
                    console.error('Error deleting product:', error);
                    throw error;
                }
            }
            
            async function uploadFile(file, type) {
                try {
                    const formData = new FormData();
                    formData.append(type === 'audio' ? 'audio' : 'image', file);
                    
                    const response = await fetch(`${API_BASE_URL}/upload/${type}`, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Failed to upload file');
                    }
                    
                    const result = await response.json();
                    // Convert relative URL to absolute if needed
                    if (result.url && !result.url.startsWith('http')) {
                        result.url = `http://localhost:3000${result.url}`;
                    }
                    return result;
                } catch (error) {
                    console.error('Error uploading file:', error);
                    throw error;
                }
            }
            
            // Render admin products list
            async function renderAdminProductsList() {
                if (!adminProductsContainer) return;
                
                try {
                    const products = await loadProducts(currentCategory);
                    if (products.length === 0) {
                        adminProductsContainer.innerHTML = '<p style="color:#666;font-style:italic;">No products yet. Add your first product!</p>';
                        return;
                    }
                
                adminProductsContainer.innerHTML = products.map((product, index) => `
                    <div class="admin-product-item">
                            ${product.image ? `<img src="${product.image.startsWith('http') ? product.image : `http://localhost:3000${product.image}`}" alt="${product.name || product.trackTitle}">` : ''}
                        <div class="admin-product-info">
                                <h4>${product.trackTitle || product.name}</h4>
                                ${currentCategory === 'music' && product.artistName ? `<p style="font-weight:bold;margin-top:3px;">${product.artistName}${product.featuredArtists ? ' feat. ' + product.featuredArtists : ''}</p>` : ''}
                                <p>${product.description || product.trackDescription || ''}</p>
                                <b>${product.price || '0'} CZK</b>
                                ${currentCategory === 'coffee' && product.roastery ? `<p style="font-size:0.8em;color:#666;">${product.roastery}</p>` : ''}
                                ${currentCategory === 'music' && product.genre ? `<p style="font-size:0.8em;color:#666;">${product.genre}${product.subgenre ? ' / ' + product.subgenre : ''}</p>` : ''}
                                ${currentCategory === 'music' && product.youtubeId ? `<p style="font-size:0.8em;color:#666;">YouTube: ${product.youtubeId}</p>` : ''}
                                ${currentCategory === 'music' && product.audioFile ? `<p style="font-size:0.8em;color:#666;">ðŸ“ Uploaded Audio</p>` : ''}
                        </div>
                        <div class="admin-product-actions">
                                <button class="admin-edit-btn" onclick="editProduct(${product.id || index})">EdIt</button>
                                <button class="admin-delete-btn" onclick="deleteProductById(${product.id || index})">DeLeTe</button>
                        </div>
                    </div>
                `).join('');
                } catch (error) {
                    console.error('Error rendering admin products:', error);
                    adminProductsContainer.innerHTML = '<p style="color:red;">ErRoR LoAdInG PrOdUcTs. ChEcK CoNsOlE.</p>';
                }
            }
            
            // Convert image file to base64
            function convertImageToBase64(file, callback) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    callback(e.target.result);
                };
                reader.onerror = function() {
                    alert('ErRoR rEaDiNg ImAgE fILe!');
                    callback(null);
                };
                reader.readAsDataURL(file);
            }
            
            // Convert audio file to base64
            function convertAudioToBase64(file, callback) {
                // Check file size (warn if > 2MB, localStorage limit is ~5-10MB total)
                const maxSize = 2 * 1024 * 1024; // 2MB in bytes
                if (file.size > maxSize) {
                    const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
                    if (!confirm(`WaRnInG: AuDiO FiLe Is ${sizeMB}MB (LaRgE)!\n\n` +
                                `StOrInG In LoCaL StOrAgE MaY ExCeEd ThE LiMiT.\n\n` +
                                `CoNtInUe AnYwAy?\n(ReCoMmEnDeD: UsE YoUtUbE InStEaD)`)) {
                        callback(null);
                        return;
                    }
                }
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    callback(e.target.result);
                };
                reader.onerror = function() {
                    alert('ErRoR rEaDiNg AuDiO fILe!');
                    callback(null);
                };
                reader.readAsDataURL(file);
            }
            
            // Handle image file upload preview
            const adminImageFile = document.getElementById('admin-image-file');
            if (adminImageFile) {
                adminImageFile.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        const preview = document.getElementById('admin-image-preview');
                        const previewImg = document.getElementById('admin-preview-img');
                        if (preview && previewImg) {
                            convertImageToBase64(file, function(base64) {
                                if (base64) {
                                    previewImg.src = base64;
                                    preview.style.display = 'block';
                                }
                            });
                        }
                    }
                });
            }
            
            // Add or update product
            async function handleProductSubmit(e) {
                e.preventDefault();
                
                console.log('Form submitted, currentCategory:', currentCategory);
                
                let name = document.getElementById('admin-name').value.trim();
                
                // For music, use track title if provided, otherwise use name field
                if (currentCategory === 'music') {
                    const trackTitle = document.getElementById('admin-track-title').value.trim();
                    name = trackTitle || name;
                    console.log('Music product - name:', name, 'trackTitle:', trackTitle);
                }
                
                const description = document.getElementById('admin-description').value.trim();
                const price = parseFloat(document.getElementById('admin-price').value);
                
                if (!name || isNaN(price)) {
                    alert('PlEaSe FiLl ReQuIrEd FiElDs (TrAcK TiTlE / NaMe & PrIcE)!');
                    return;
                }
                
                console.log('Validation passed, name:', name, 'price:', price);
                
                // Get image - either from file upload or URL (optional for some categories)
                const imageFile = document.getElementById('admin-image-file').files[0];
                const imageUrl = document.getElementById('admin-image-url').value.trim();
                
                // For coffee products, require image unless editing (existing image will be preserved)
                if (currentCategory !== 'music' && !imageFile && !imageUrl) {
                    // If editing, check if product already has an image
                    if (editingIndex !== null) {
                        try {
                            const products = await loadProducts(currentCategory);
                            const productToCheck = typeof editingIndex === 'number' 
                                ? products[editingIndex] 
                                : products.find(p => p.id === editingIndex);
                            
                            // If editing and product has existing image, allow submission
                            if (productToCheck && productToCheck.image) {
                                console.log('Editing: product has existing image, validation passed');
                            } else {
                    alert('PlEaSe UpLoAd An ImAgE oR pRoViDe An ImAgE uRl!');
                    return;
                            }
                        } catch (error) {
                            console.error('Error checking existing product:', error);
                            alert('PlEaSe UpLoAd An ImAgE oR pRoViDe An ImAgE uRl!');
                            return;
                        }
                    } else {
                        // Creating new product - image is required
                        alert('PlEaSe UpLoAd An ImAgE oR pRoViDe An ImAgE uRl!');
                        return;
                    }
                }
                
                // Process files and create product using API
                const processProduct = async (finalImageUrl, finalAudioUrl = null) => {
                    console.log('processProduct called for category:', currentCategory, 'imageUrl:', !!finalImageUrl, 'audioUrl:', !!finalAudioUrl);
                    
                    const productData = {
                        name: name,
                        description: description || '',
                        price: price,
                        category: currentCategory
                    };
                    
                    // Add image if provided (required for coffee)
                    if (finalImageUrl) {
                        productData.image = finalImageUrl;
                        console.log('Image added to productData:', finalImageUrl);
                    } else if (currentCategory === 'coffee') {
                        // Coffee products must have an image - validation should have caught this, but double-check
                        console.error('Coffee product missing image! finalImageUrl:', finalImageUrl);
                        alert('PlEaSe UpLoAd An ImAgE oR pRoViDe An ImAgE uRl!');
                        throw new Error('Image required for coffee products');
                    }
                    
                    // Category-specific fields
                    if (currentCategory === 'coffee') {
                        productData.roastery = document.getElementById('admin-roastery').value.trim() || '';
                        productData.origin = document.getElementById('admin-origin').value.trim() || '';
                        productData.region = document.getElementById('admin-region').value.trim() || '';
                        productData.variety = document.getElementById('admin-variety').value.trim() || '';
                        productData.roastType = document.getElementById('admin-roast-type').value.trim() || '';
                        productData.process = document.getElementById('admin-process').value.trim() || '';
                        productData.flavour = document.getElementById('admin-flavour').value.trim() || '';
                        productData.roastLevel = document.getElementById('admin-roast-level').value.trim() || '';
                        productData.brewing = document.getElementById('admin-brewing').value.trim() || '';
                        productData.packageSize = document.getElementById('admin-package-size').value.trim() || '';
                        productData.aboutCoffee = document.getElementById('admin-about-coffee').value.trim() || '';
                        productData.aboutRoastery = document.getElementById('admin-about-roastery').value.trim() || '';
                        productData.altitude = document.getElementById('admin-altitude').value.trim() || '';
                        productData.processingStation = document.getElementById('admin-processing-station').value.trim() || '';
                    } else if (currentCategory === 'music') {
                        const musicSourceRadio = document.querySelector('input[name="music-source"]:checked');
                        const musicSource = musicSourceRadio ? musicSourceRadio.value : 'youtube';
                        productData.trackTitle = document.getElementById('admin-track-title').value.trim() || name;
                        productData.artistName = document.getElementById('admin-artist-name').value.trim() || '';
                        productData.featuredArtists = document.getElementById('admin-featured-artists').value.trim() || '';
                        productData.releaseDate = document.getElementById('admin-release-date').value || '';
                        productData.recordLabel = document.getElementById('admin-record-label').value.trim() || '';
                        productData.genre = document.getElementById('admin-genre').value.trim() || '';
                        productData.subgenre = document.getElementById('admin-subgenre').value.trim() || '';
                        productData.trackDescription = document.getElementById('admin-track-description').value.trim() || '';
                        productData.keywords = document.getElementById('admin-keywords').value.trim() || '';
                        productData.musicSource = musicSource;
                        
                        if (musicSource === 'youtube') {
                            const youtubeId = document.getElementById('admin-youtube-id').value.trim();
                            productData.youtubeId = youtubeId || null;
                            productData.audioFile = null;
                            productData.soundcloudUrl = null;
                        } else if (musicSource === 'soundcloud') {
                            const soundcloudUrl = document.getElementById('admin-soundcloud-url').value.trim();
                            productData.soundcloudUrl = soundcloudUrl || null;
                            productData.youtubeId = null;
                            productData.audioFile = null;
                        } else {
                            // Set audio file URL
                            productData.youtubeId = null;
                            productData.soundcloudUrl = null;
                            productData.audioFile = finalAudioUrl || null;
                        }
                    }
                    
                    console.log('Saving product via API:', productData);
                    
                    try {
                        let savedProduct;
                    if (editingIndex !== null) {
                            // Update existing product - need to get product ID
                            const products = await loadProducts(currentCategory);
                            
                            // Try to find product by ID first, then by index
                            let productToUpdate = null;
                            
                            // First, try to find by ID (string or number match)
                            productToUpdate = products.find(p => {
                                if (!p.id) return false;
                                return p.id === editingIndex || 
                                       p.id === String(editingIndex) || 
                                       String(p.id) === String(editingIndex);
                            });
                            
                            // If not found by ID and editingIndex is a number, try as array index
                            if (!productToUpdate && typeof editingIndex === 'number' && editingIndex < products.length) {
                                productToUpdate = products[editingIndex];
                            }
                            
                            // Last resort: use stored product reference if available
                            if (!productToUpdate && window._editingProduct) {
                                productToUpdate = window._editingProduct;
                            }
                            
                            if (!productToUpdate) {
                                console.error('Product not found. editingIndex:', editingIndex, 'Products count:', products.length, 'Products:', products);
                                throw new Error('Product not found for update. The product list may have changed. Please try editing again.');
                            }
                            
                            if (!productToUpdate.id) {
                                console.error('Product found but has no ID. Product:', productToUpdate);
                                throw new Error('Product ID not found for update. The product may need to be recreated. Product name: ' + (productToUpdate.name || productToUpdate.trackTitle || 'Unknown'));
                            }
                            
                            console.log('Updating product with ID:', productToUpdate.id);
                            
                            savedProduct = await updateProduct(currentCategory, productToUpdate.id, productData);
                        alert('PrOdUcT UpDaTeD!');
                    } else {
                            // Create new product
                            savedProduct = await createProduct(currentCategory, productData);
                        alert('PrOdUcT AdDeD!');
                    }
                    
                        console.log('Product saved successfully:', savedProduct);
                        
                        // Refresh category display on frontend
                        if (currentCategory === 'coffee') {
                            await renderCoffeeProducts();
                        } else if (currentCategory === 'music') {
                            await renderMusicProducts();
                        } else if (currentCategory === 'arts') {
                            await renderArtsProducts();
                        } else if (currentCategory === 'fashion') {
                            await renderFashionProducts();
                        } else if (currentCategory === 'crafts') {
                            await renderCraftsProducts();
                        }
                        
                        await renderAdminProductsList();
                    adminForm.reset();
                    document.getElementById('admin-image-preview').style.display = 'none';
                        document.getElementById('admin-music-preview').style.display = 'none';
                        const musicSourceRadios = document.querySelectorAll('input[name="music-source"]');
                        if (musicSourceRadios.length > 0) {
                            musicSourceRadios[0].checked = true;
                            document.getElementById('music-youtube-section').style.display = 'block';
                            document.getElementById('music-upload-section').style.display = 'none';
                        }
                    editingIndex = null;
                    window._editingProduct = null; // Clear stored product reference
                    document.getElementById('admin-submit').textContent = 'AdD PrOdUcT';
                    adminCancelEdit.style.display = 'none';
                    } catch (error) {
                        console.error('Error saving product:', error);
                        alert('ErRoR SaViNg PrOdUcT: ' + error.message);
                    }
                };
                
                // Handle file uploads via API
                try {
                    let imageUrlToUse = null;
                    let audioUrlToUse = null;
                    
                    console.log('Image handling - imageFile:', !!imageFile, 'imageUrl:', imageUrl);
                    
                    // If editing and no new image provided, preserve existing image
                    if (editingIndex !== null && currentCategory !== 'music' && !imageFile && !imageUrl) {
                        const products = await loadProducts(currentCategory);
                        const productToCheck = typeof editingIndex === 'number' 
                            ? products[editingIndex] 
                            : products.find(p => p.id === editingIndex);
                        
                        if (productToCheck && productToCheck.image) {
                            imageUrlToUse = productToCheck.image;
                            console.log('Preserving existing image:', imageUrlToUse);
                        }
                } else {
                        // Upload image if file provided
                        if (imageFile) {
                            console.log('Uploading image file...');
                            const imageUploadResult = await uploadFile(imageFile, 'image');
                            imageUrlToUse = imageUploadResult.url;
                            console.log('Image uploaded:', imageUrlToUse);
                        } else if (imageUrl && imageUrl.trim()) {
                            // Use provided image URL
                            imageUrlToUse = imageUrl.trim();
                            console.log('Using image URL:', imageUrlToUse);
                        }
                    }
                    
                    console.log('Final imageUrlToUse:', imageUrlToUse);
                    
                    // Handle music audio file upload if needed
                    if (currentCategory === 'music') {
                        const musicSourceRadio = document.querySelector('input[name="music-source"]:checked');
                        if (!musicSourceRadio) {
                            alert('PlEaSe SeLeCt A MuSiC SoUrCe (YoUtUbE oR UpLoAd)!');
                            return;
                        }
                        const musicSource = musicSourceRadio.value;
                        const musicFile = document.getElementById('admin-music-file').files[0];
                        
                        // Check if we're editing and already have an audio file
                        if (editingIndex !== null) {
                            const products = await loadProducts(currentCategory);
                            const productToCheck = typeof editingIndex === 'number' 
                                ? products[editingIndex] 
                                : products.find(p => p.id === editingIndex);
                            
                            if (productToCheck && productToCheck.audioFile) {
                                audioUrlToUse = productToCheck.audioFile;
                            }
                        }
                        
                        if (musicSource === 'upload') {
                            if (musicFile) {
                                console.log('Uploading audio file...');
                                const audioUploadResult = await uploadFile(musicFile, 'audio');
                                audioUrlToUse = audioUploadResult.url;
                                console.log('Audio uploaded:', audioUrlToUse);
                            } else if (!audioUrlToUse) {
                                console.log('No audio file provided, will save with null');
                            }
                        }
                    }
                    
                    // Process product with uploaded URLs
                    await processProduct(imageUrlToUse, audioUrlToUse);
                    
                } catch (error) {
                    console.error('Error uploading files:', error);
                    alert('ErRoR UpLoAdInG FiLeS: ' + error.message);
                }
            }
            
            // Edit product
            window.editProduct = async function(productIdOrIndex) {
                const products = await loadProducts(currentCategory);
                const product = typeof productIdOrIndex === 'number' && productIdOrIndex < products.length
                    ? products[productIdOrIndex]
                    : products.find(p => p.id === productIdOrIndex) || products[productIdOrIndex];
                
                if (!product) {
                    alert('PrOdUcT nOt FoUnD!');
                    return;
                }
                
                // Fill common form fields
                // For music, use trackTitle for name field if available
                if (currentCategory === 'music' && product.trackTitle) {
                    document.getElementById('admin-name').value = product.trackTitle || '';
                } else {
                document.getElementById('admin-name').value = product.name || '';
                }
                document.getElementById('admin-description').value = product.description || product.trackDescription || '';
                document.getElementById('admin-price').value = product.price || '';
                
                // Handle image - if it's base64, show preview; otherwise use URL field
                const preview = document.getElementById('admin-image-preview');
                const previewImg = document.getElementById('admin-preview-img');
                if (product.image) {
                    if (product.image.startsWith('data:image')) {
                    // Base64 image
                    if (previewImg) previewImg.src = product.image;
                    if (preview) preview.style.display = 'block';
                    document.getElementById('admin-image-url').value = '';
                } else {
                    // URL image
                    document.getElementById('admin-image-url').value = product.image || '';
                        if (preview) preview.style.display = 'none';
                    }
                } else {
                    document.getElementById('admin-image-url').value = '';
                    if (preview) preview.style.display = 'none';
                }
                document.getElementById('admin-image-file').value = ''; // Clear file input
                
                // Fill category-specific fields
                if (currentCategory === 'coffee') {
                document.getElementById('admin-roastery').value = product.roastery || '';
                document.getElementById('admin-origin').value = product.origin || '';
                document.getElementById('admin-region').value = product.region || '';
                document.getElementById('admin-variety').value = product.variety || '';
                document.getElementById('admin-roast-type').value = product.roastType || '';
                document.getElementById('admin-process').value = product.process || '';
                document.getElementById('admin-flavour').value = product.flavour || '';
                document.getElementById('admin-roast-level').value = product.roastLevel || '';
                document.getElementById('admin-brewing').value = product.brewing || '';
                document.getElementById('admin-package-size').value = product.packageSize || '';
                document.getElementById('admin-about-coffee').value = product.aboutCoffee || '';
                document.getElementById('admin-about-roastery').value = product.aboutRoastery || '';
                document.getElementById('admin-altitude').value = product.altitude || '';
                document.getElementById('admin-processing-station').value = product.processingStation || '';
                } else if (currentCategory === 'music') {
                    document.getElementById('admin-track-title').value = product.trackTitle || product.name || '';
                    document.getElementById('admin-artist-name').value = product.artistName || '';
                    document.getElementById('admin-featured-artists').value = product.featuredArtists || '';
                    document.getElementById('admin-release-date').value = product.releaseDate || '';
                    document.getElementById('admin-record-label').value = product.recordLabel || '';
                    document.getElementById('admin-genre').value = product.genre || '';
                    document.getElementById('admin-subgenre').value = product.subgenre || '';
                    document.getElementById('admin-track-description').value = product.trackDescription || '';
                    document.getElementById('admin-keywords').value = product.keywords || '';
                    
                    const musicSource = product.musicSource || 'youtube';
                    const musicSourceRadio = document.querySelector(`input[name="music-source"][value="${musicSource}"]`);
                    if (musicSourceRadio) {
                        musicSourceRadio.checked = true;
                    }
                    
                    if (musicSource === 'youtube') {
                        document.getElementById('admin-youtube-id').value = product.youtubeId || '';
                        document.getElementById('music-youtube-section').style.display = 'block';
                        document.getElementById('music-soundcloud-section').style.display = 'none';
                        document.getElementById('music-upload-section').style.display = 'none';
                    } else if (musicSource === 'soundcloud') {
                        document.getElementById('admin-soundcloud-url').value = product.soundcloudUrl || '';
                        document.getElementById('music-youtube-section').style.display = 'none';
                        document.getElementById('music-soundcloud-section').style.display = 'block';
                        document.getElementById('music-upload-section').style.display = 'none';
                    } else {
                        document.getElementById('admin-youtube-id').value = '';
                        document.getElementById('admin-soundcloud-url').value = '';
                        document.getElementById('music-youtube-section').style.display = 'none';
                        document.getElementById('music-soundcloud-section').style.display = 'none';
                        document.getElementById('music-upload-section').style.display = 'block';
                        if (product.audioFile) {
                            const preview = document.getElementById('admin-music-preview');
                            const previewAudio = document.getElementById('admin-preview-audio');
                            if (preview && previewAudio) {
                                previewAudio.src = product.audioFile;
                                preview.style.display = 'block';
                            }
                        }
                    }
                }
                
                // Store product ID for editing - prefer ID over index
                if (product.id) {
                    editingIndex = product.id;
                } else if (typeof productIdOrIndex === 'number') {
                    // If no ID, store the index but also store the product reference
                    editingIndex = productIdOrIndex;
                    // Store product reference as fallback
                    window._editingProduct = product;
                } else {
                    editingIndex = productIdOrIndex;
                }
                
                console.log('Editing product. ID:', product.id, 'editingIndex:', editingIndex, 'productIdOrIndex:', productIdOrIndex);
                
                document.getElementById('admin-submit').textContent = 'UpDaTe PrOdUcT';
                adminCancelEdit.style.display = 'inline-block';
                
                // Scroll to form
                document.getElementById('admin-form-section').scrollIntoView({ behavior: 'smooth' });
            };
            
            // Delete product by ID
            window.deleteProductById = async function(productId) {
                if (!confirm('R u SuRe U wAnT 2 DeLeTe ThIs PrOdUcT? ðŸ˜¢')) {
                    return;
                }
                
                try {
                    await deleteProduct(currentCategory, productId);
                    
                    // Refresh category display on frontend
                    if (currentCategory === 'coffee') {
                        await renderCoffeeProducts();
                    } else if (currentCategory === 'music') {
                        await renderMusicProducts();
                    } else if (currentCategory === 'arts') {
                        await renderArtsProducts();
                    } else if (currentCategory === 'fashion') {
                        await renderFashionProducts();
                    } else if (currentCategory === 'crafts') {
                        await renderCraftsProducts();
                    }
                    
                    await renderAdminProductsList();
                alert('PrOdUcT DeLeTeD!');
                } catch (error) {
                    console.error('Error deleting product:', error);
                    alert('ErRoR DeLeTiNg PrOdUcT: ' + error.message);
                }
            };
            
            // Legacy deleteProduct function (for backward compatibility)
            window.deleteProduct = async function(index) {
                const products = await loadProducts(currentCategory);
                const product = products[index];
                if (product && product.id) {
                    await window.deleteProductById(product.id);
                } else {
                    alert('PrOdUcT nOt FoUnD!');
                }
            };
            
            // Event listeners
            if (adminToggle) {
                adminToggle.addEventListener('click', function(e) {
                    e.preventDefault();
                    openAdminPanel();
                });
            }
            
            if (adminClose) {
                adminClose.addEventListener('click', closeAdminPanel);
            }
            
            if (adminOverlay) {
                adminOverlay.addEventListener('click', closeAdminPanel);
            }
            
            if (adminForm) {
                adminForm.addEventListener('submit', handleProductSubmit);
            }
            
            if (adminCancelEdit) {
                adminCancelEdit.addEventListener('click', function() {
                    editingIndex = null;
                    adminForm.reset();
                    document.getElementById('admin-image-preview').style.display = 'none';
                    document.getElementById('admin-submit').textContent = 'AdD PrOdUcT';
                    adminCancelEdit.style.display = 'none';
                });
            }
            
            // Clear preview when URL is entered
            const adminImageUrl = document.getElementById('admin-image-url');
            if (adminImageUrl) {
                adminImageUrl.addEventListener('input', function() {
                    if (this.value.trim()) {
                        document.getElementById('admin-image-preview').style.display = 'none';
                        document.getElementById('admin-image-file').value = '';
                    }
                });
            }
            
            // Handle music source toggle (YouTube vs Upload)
            const musicSourceRadios = document.querySelectorAll('input[name="music-source"]');
            const musicYoutubeSection = document.getElementById('music-youtube-section');
            const musicSoundcloudSection = document.getElementById('music-soundcloud-section');
            const musicUploadSection = document.getElementById('music-upload-section');
            
            musicSourceRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    if (this.value === 'youtube') {
                        if (musicYoutubeSection) musicYoutubeSection.style.display = 'block';
                        if (musicSoundcloudSection) musicSoundcloudSection.style.display = 'none';
                        if (musicUploadSection) musicUploadSection.style.display = 'none';
                        document.getElementById('admin-music-file').value = '';
                        document.getElementById('admin-music-preview').style.display = 'none';
                    } else if (this.value === 'soundcloud') {
                        if (musicYoutubeSection) musicYoutubeSection.style.display = 'none';
                        if (musicSoundcloudSection) musicSoundcloudSection.style.display = 'block';
                        if (musicUploadSection) musicUploadSection.style.display = 'none';
                        document.getElementById('admin-music-file').value = '';
                        document.getElementById('admin-music-preview').style.display = 'none';
                    } else {
                        if (musicYoutubeSection) musicYoutubeSection.style.display = 'none';
                        if (musicSoundcloudSection) musicSoundcloudSection.style.display = 'none';
                        if (musicUploadSection) musicUploadSection.style.display = 'block';
                        document.getElementById('admin-youtube-id').value = '';
                    }
                });
            });
            
            // Handle music file upload preview
            const adminMusicFile = document.getElementById('admin-music-file');
            if (adminMusicFile) {
                adminMusicFile.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        const preview = document.getElementById('admin-music-preview');
                        const previewAudio = document.getElementById('admin-preview-audio');
                        if (preview && previewAudio) {
                            const url = URL.createObjectURL(file);
                            previewAudio.src = url;
                            preview.style.display = 'block';
                        }
                    } else {
                        document.getElementById('admin-music-preview').style.display = 'none';
                    }
                });
            }
            
            // Render music products - make it globally accessible
            window.renderMusicProducts = async function() {
                const container = document.getElementById('music-products-container');
                if (!container) {
                    console.error('Music products container not found!');
                    return;
                }
                
                try {
                    let products = await loadProducts('music');
                    console.log('Loading music products:', products);
                    
                    // Add 4 test music tracks for testing purposes
                    const testMusicTracks = [
                        {
                            trackTitle: 'TeSt TrAcK 1 - YoUtUbE',
                            artistName: 'TeSt ArTiSt',
                            price: 15.00,
                            image: 'https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?auto=format&fit=crop&w=400&h=400&q=80',
                            musicSource: 'youtube',
                            youtubeId: 'dQw4w9WgXcQ',
                            genre: 'TeSt GeNrE',
                            trackDescription: 'TeSt TrAcK WiTh YoUtUbE SoUrCe'
                        },
                        {
                            trackTitle: 'TeSt TrAcK 2 - SoUnDcLoUd',
                            artistName: 'TeSt BaNd',
                            price: 20.00,
                            image: 'https://images.unsplash.com/photo-1511379938547-c1f69419868d?auto=format&fit=crop&w=400&h=400&q=80',
                            musicSource: 'soundcloud',
                            soundcloudUrl: 'https://soundcloud.com/chillhopdotcom/chillhop-essentials-fall-2023',
                            genre: 'Lo-Fi',
                            trackDescription: 'TeSt TrAcK WiTh SoUnDcLoUd SoUrCe'
                        },
                        {
                            trackTitle: 'TeSt TrAcK 3 - UpLoAd',
                            artistName: 'TeSt MuSiCiAn',
                            price: 18.00,
                            image: 'https://images.unsplash.com/photo-1516280440614-37939bbacd81?auto=format&fit=crop&w=400&h=400&q=80',
                            musicSource: 'upload',
                            audioFile: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3',
                            genre: 'ElEcTrOnIc',
                            trackDescription: 'TeSt TrAcK WiTh UpLoAdEd AuDiO'
                        },
                        {
                            trackTitle: 'TeSt TrAcK 4 - SoUnDcLoUd 2',
                            artistName: 'TeSt CoLlEcTiVe',
                            price: 22.00,
                            image: 'https://images.unsplash.com/photo-1514320291840-2e0a9bf2a9ae?auto=format&fit=crop&w=400&h=400&q=80',
                            musicSource: 'soundcloud',
                            soundcloudUrl: 'https://soundcloud.com/chillhopdotcom/chillhop-essentials-spring-2023',
                            genre: 'ChIlL HoP',
                            trackDescription: 'AnOtHeR TeSt TrAcK WiTh SoUnDcLoUd'
                        }
                    ];
                    
                    // Combine backend products with test tracks
                    products = [...products, ...testMusicTracks];
                    
                    if (products.length === 0) {
                        container.innerHTML = '<p style="text-align:center;color:#666;font-style:italic;">No music products yet. Add your first product in admin!</p>';
                        return;
                    }
                    
                    container.innerHTML = products.map(product => {
                    const youtubeId = product.youtubeId || '';
                    const audioFile = product.audioFile || '';
                    const soundcloudUrl = product.soundcloudUrl || '';
                    const musicSource = product.musicSource || 'youtube';
                    const trackTitle = product.trackTitle || product.name || 'Unnamed Track';
                    const artistName = product.artistName || '';
                    const featuredArtists = product.featuredArtists || '';
                    const releaseDate = product.releaseDate || '';
                    const recordLabel = product.recordLabel || '';
                    const genre = product.genre || '';
                    const subgenre = product.subgenre || '';
                    const trackDescription = product.trackDescription || product.description || '';
                    const keywords = product.keywords || '';
                    const name = product.name || trackTitle;
                    const price = product.price || 0;
                    const image = product.image || '';
                    
                    // Format release date for display
                    let formattedDate = '';
                    if (releaseDate) {
                        const date = new Date(releaseDate);
                        if (!isNaN(date.getTime())) {
                            formattedDate = date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
                        }
                    }
                    
                    // Build artist display
                    let artistDisplay = artistName;
                    if (featuredArtists) {
                        artistDisplay += featuredArtists ? ` feat. ${featuredArtists}` : '';
                    }
                    
                    // Build genre display
                    let genreDisplay = genre;
                    if (subgenre) {
                        genreDisplay += subgenre ? ` / ${subgenre}` : '';
                    }
                    
                    return `
                    <div class="music-product record-player-card" 
                         data-youtube-id="${youtubeId}" 
                         data-audio-file="${audioFile ? 'yes' : ''}"
                         data-soundcloud-url="${soundcloudUrl}"
                         data-music-source="${musicSource}">
                        <div class="record-player-base">
                            <div class="record-disc">
                                ${image ? `<img class="record-album-art" src="${image}" alt="${trackTitle}">` : ''}
                                <div class="record-center"></div>
                                <div class="record-lines"></div>
                            </div>
                            <div class="record-arm">
                                <div class="arm-base"></div>
                                <div class="arm-rod"></div>
                                <div class="arm-head"></div>
                            </div>
                            <div class="play-button-wrapper">
                                <button class="skip-button" data-action="skip-backward">â®</button>
                                <button class="play-button">â–¶</button>
                                <button class="skip-button" data-action="skip-forward">â­</button>
                            </div>
                        </div>
                        <div class="music-info">
                            <h3>${trackTitle}</h3>
                            ${artistDisplay ? `<p style="font-weight:bold;margin-top:5px;">${artistDisplay}</p>` : ''}
                            ${formattedDate ? `<p style="font-size:0.9em;color:#666;margin-top:3px;">${formattedDate}</p>` : ''}
                            ${recordLabel ? `<p style="font-size:0.85em;color:#666;margin-top:3px;">${recordLabel}</p>` : ''}
                            ${genreDisplay ? `<p style="font-size:0.85em;color:#888;margin-top:3px;">${genreDisplay}</p>` : ''}
                            ${trackDescription ? `<p style="font-size:0.9em;margin-top:8px;line-height:1.4;">${trackDescription}</p>` : ''}
                            ${keywords ? `<p style="font-size:0.8em;color:#999;margin-top:5px;font-style:italic;">${keywords}</p>` : ''}
                            <b style="margin-top:10px;display:block;">${price} CZK</b>
                        </div>
                        <div class="youtube-player-container" style="display: none;"></div>
                        ${audioFile ? `<audio class="audio-player" style="display:none;" preload="metadata"></audio>` : ''}
                        ${soundcloudUrl ? `<div class="soundcloud-player-container" style="display: none;"></div>` : ''}
                    </div>
                    `;
                    }).join('');
                    
                    // Re-initialize music player handlers after rendering
                    initializeMusicPlayers();
                } catch (error) {
                    console.error('Error rendering music products:', error);
                    container.innerHTML = '<p style="text-align:center;color:red;">Error displaying music products. Check console for details.</p>';
                }
            };
            
            // Render crafts products from backend
            window.renderCraftsProducts = async function() {
                const container = document.getElementById('crafts-products-container');
                if (!container) {
                    console.error('Crafts products container not found!');
                    return;
                }
                
                try {
                    let products = await loadProducts('crafts');
                    console.log('Loading crafts products:', products);
                    
                    // Add test products if none exist (for testing)
                    if (products.length === 0) {
                        products = [
                            {
                                name: 'HaNdMaDe MuG',
                                price: 12.00,
                                image: 'https://images.unsplash.com/photo-1581833971358-2c8b550f87b3?auto=format&fit=crop&w=400&h=400&q=80',
                                description: 'Custom ceramic mug'
                            },
                            {
                                name: 'KnItTeD sCaRf',
                                price: 20.00,
                                image: 'https://images.unsplash.com/photo-1581833971358-2c8b550f87b3?auto=format&fit=crop&w=400&h=400&q=80',
                                description: 'Cozy handmade scarf'
                            },
                            {
                                name: 'CrOcHeT bAg',
                                price: 28.00,
                                image: 'https://images.unsplash.com/photo-1581833971358-2c8b550f87b3?auto=format&fit=crop&w=400&h=400&q=80',
                                description: 'Vintage crochet style'
                            },
                            {
                                name: 'PoTtErY vAsE',
                                price: 35.00,
                                image: 'https://images.unsplash.com/photo-1581833971358-2c8b550f87b3?auto=format&fit=crop&w=400&h=400&q=80',
                                description: 'Handcrafted ceramic vase'
                            },
                            {
                                name: 'WoVeN bAsKeT',
                                price: 22.00,
                                image: 'https://images.unsplash.com/photo-1581833971358-2c8b550f87b3?auto=format&fit=crop&w=400&h=400&q=80',
                                description: 'Natural fiber basket'
                            }
                        ];
                    }
                    
                    container.innerHTML = products.map((product, index) => {
                        const name = product.name || 'Unnamed Craft';
                        const price = product.price || 0;
                        const image = product.image || '';
                        const description = product.description || '';
                        const imageUrl = image && image.startsWith('http') 
                            ? image 
                            : (image && image.startsWith('/') ? `http://localhost:3000${image}` : image);
                        
                        return `
                    <div class="product crafts-product" 
                         data-name="${name}" 
                         data-price="${price}" 
                         data-image="${imageUrl}" 
                         data-short="${description}" 
                         data-description="${description}">
                        <img src="${imageUrl}" alt="${name}" onload="this.style.display='block'" onerror="this.style.display='none'">
                        <div class="crafts-price-tag">
                            <span>$${price.toFixed(2)}</span>
                            <button class="crafts-add-to-cart-btn" data-name="${name}" onclick="event.stopPropagation(); if(typeof window.addToCart === 'function') { window.addToCart('${name}', ${price}, '${imageUrl}'); if(typeof window.updateButtonStates === 'function') window.updateButtonStates(); }">+ CaRt</button>
                        </div>
                    </div>
                    `;
                    }).join('');
                    
                    // Re-initialize crafts frame positioning after rendering
                    initializeCraftsFrames();
                    
                    // Re-initialize category headings parallax
                    if (typeof initializeCategoryHeadingsParallax === 'function') {
                        setTimeout(() => initializeCategoryHeadingsParallax(), 50);
                    }
                    
                    // Re-initialize crafts click handlers
                    const craftsContainer = document.getElementById('crafts-products-container');
                    if (craftsContainer) {
                        // Remove old listener if exists
                        if (craftsContainer._craftsClickHandler) {
                            craftsContainer.removeEventListener('click', craftsContainer._craftsClickHandler);
                        }
                        
                        // Create new click handler for crafts
                        craftsContainer._craftsClickHandler = function(e) {
                            const craftsProduct = e.target.closest('.crafts-product');
                            if (!craftsProduct) return;
                            
                            // Don't open if clicking the add to cart button
                            if (e.target.closest('.crafts-add-to-cart-btn')) {
                                return;
                            }
                            
                            const name = craftsProduct.getAttribute('data-name');
                            const price = craftsProduct.getAttribute('data-price');
                            const image = craftsProduct.getAttribute('data-image');
                            const short = craftsProduct.getAttribute('data-short');
                            const description = craftsProduct.getAttribute('data-description');
                            
                            if (name && price && image) {
                                if (typeof window.openArtsProductDetail === 'function') {
                                    window.openArtsProductDetail(name, price, image, short || description, description, craftsProduct);
                                } else if (typeof window.openProductDetail === 'function') {
                                    window.openProductDetail(name, price, image, short || description, description);
                                }
                            }
                        };
                        
                        craftsContainer.addEventListener('click', craftsContainer._craftsClickHandler);
                    }
                } catch (error) {
                    console.error('Error rendering crafts products:', error);
                    container.innerHTML = '<p style="text-align:center;color:red;">Error displaying crafts products. Check console for details.</p>';
                }
            };
            
            // Render arts products from backend
            window.renderArtsProducts = async function() {
                const container = document.getElementById('arts-products-container');
                if (!container) {
                    console.error('Arts products container not found!');
                    return;
                }
                
                try {
                    const products = await loadProducts('arts');
                    console.log('Loading arts products:', products);
                    
                    if (products.length === 0) {
                        container.innerHTML = '<p style="text-align:center;color:#666;font-style:italic;">No arts products yet. Add your first product in admin!</p>';
                        return;
                    }
                    
                    container.innerHTML = products.map((product, index) => {
                        const name = product.name || 'Unnamed Art';
                        const price = product.price || 0;
                        const image = product.image || '';
                        const description = product.description || '';
                        const imageUrl = image && image.startsWith('http') 
                            ? image 
                            : (image && image.startsWith('/') ? `http://localhost:3000${image}` : image);
                        
                        // Assign data-art based on index for frame variations
                        const artIndex = (index % 9) + 1;
                        
                        return `
                    <div class="art-frame" 
                         data-art="${artIndex}" 
                         data-name="${name}" 
                         data-price="${price}" 
                         data-image="${imageUrl}" 
                         data-short="${description}" 
                         data-description="${description}">
                        <div class="frame-inner">
                            <img src="${imageUrl}" alt="${name}" onload="this.style.display='block'" onerror="this.style.display='none'">
                            <div class="art-price-tag">
                                <span>$${price.toFixed(2)}</span>
                                <button class="art-add-to-cart-btn" data-name="${name}" onclick="event.stopPropagation(); if(typeof window.addToCart === 'function') { window.addToCart('${name}', ${price}, '${imageUrl}'); if(typeof window.updateButtonStates === 'function') window.updateButtonStates(); }">+ CaRt</button>
                            </div>
                        </div>
                    </div>
                    `;
                    }).join('');
                    
                    // Re-initialize art frame positioning after rendering
                    initializeArtsFrames();
                    
                    // Re-initialize art frame click handlers
                    const artsContainer = document.getElementById('arts-products-container');
                    if (artsContainer) {
                        // Remove old listener if exists
                        if (artsContainer._artsClickHandler) {
                            artsContainer.removeEventListener('click', artsContainer._artsClickHandler);
                        }
                        
                        // Create new click handler for arts
                        artsContainer._artsClickHandler = function(e) {
                            const artFrame = e.target.closest('.art-frame');
                            if (!artFrame) return;
                            
                            // Don't open if clicking the add to cart button
                            if (e.target.closest('.art-add-to-cart-btn')) {
                                return;
                            }
                            
                            const name = artFrame.getAttribute('data-name');
                            const price = artFrame.getAttribute('data-price');
                            const image = artFrame.getAttribute('data-image');
                            const short = artFrame.getAttribute('data-short');
                            const description = artFrame.getAttribute('data-description');
                            
                            if (name && price && image) {
                                if (typeof window.openArtsProductDetail === 'function') {
                                    window.openArtsProductDetail(name, price, image, short || description, description, artFrame);
                                } else if (typeof window.openProductDetail === 'function') {
                                    window.openProductDetail(name, price, image, short || description, description);
                                }
                            }
                        };
                        
                        artsContainer.addEventListener('click', artsContainer._artsClickHandler);
                    }
                    
                    // Re-initialize category headings parallax
                    if (typeof initializeCategoryHeadingsParallax === 'function') {
                        setTimeout(() => initializeCategoryHeadingsParallax(), 50);
                    }
                } catch (error) {
                    console.error('Error rendering arts products:', error);
                    container.innerHTML = '<p style="text-align:center;color:red;">Error displaying arts products. Check console for details.</p>';
                }
            };
            
            // Initialize art frames positioning (chaotic layout)
            function initializeArtsFrames() {
                const artFrames = document.querySelectorAll('.art-frame');
                if (artFrames.length === 0) return;
                
                // More chaotic rotations and positions for disorganized gallery
                artFrames.forEach((frame, index) => {
                    // Random rotation between -10.5 and +10.5 degrees (30% less than -15 to +15)
                    const rotation = (Math.random() * 21) - 10.5;
                    
                    // Random slight position offset for more chaos (also 30% less)
                    const offsetX = (Math.random() * 28) - 14; // -14px to +14px (30% less)
                    const offsetY = (Math.random() * 28) - 14; // -14px to +14px (30% less)
                    
                    // Store original transform for hover
                    const baseTransform = `rotate(${rotation}deg) translate(${offsetX}px, ${offsetY}px)`;
                    frame._originalTransform = baseTransform;
                    
                    // Apply random rotation and position
                    frame.style.transform = baseTransform;
                    frame.style.margin = '0';
                    
                    // Add hover effect that preserves rotation and adds scale
                    frame.addEventListener('mouseenter', function() {
                        if (this._originalTransform) {
                            this.style.transform = this._originalTransform + ' scale(1.05)';
                        }
                    });
                    
                    frame.addEventListener('mouseleave', function() {
                        if (this._originalTransform) {
                            this.style.transform = this._originalTransform;
                        }
                    });
                });
            }
            
            // Render fashion products from backend
            window.renderFashionProducts = async function() {
                const container = document.getElementById('fashion-products-container');
                if (!container) {
                    console.error('Fashion products container not found!');
                    return;
                }
                
                try {
                    let products = await loadProducts('fashion');
                    console.log('Loading fashion products:', products);
                    
                    // Add 6 test products for testing purposes
                    const testProducts = [
                        {
                            name: 'TeSt BaG 1',
                            price: 45.00,
                            image: 'https://images.unsplash.com/photo-1553062407-98eeb64c6a62?auto=format&fit=crop&w=400&h=400&q=80',
                            description: 'CoOl TeSt BaG FoR TeStInG'
                        },
                        {
                            name: 'TeSt ToTe 2',
                            price: 35.00,
                            image: 'https://images.unsplash.com/photo-1590874103328-eac38a683ce7?auto=format&fit=crop&w=400&h=400&q=80',
                            description: 'StYlIsH ToTe BaG'
                        },
                        {
                            name: 'TeSt ShIrT 3',
                            price: 55.00,
                            image: 'https://images.unsplash.com/photo-1521572163474-6864f9cf17ab?auto=format&fit=crop&w=400&h=400&q=80',
                            description: 'CoOl TeSt ShIrT'
                        },
                        {
                            name: 'TeSt HaT 4',
                            price: 25.00,
                            image: 'https://images.unsplash.com/photo-1588850561407-ed78c282e89b?auto=format&fit=crop&w=400&h=400&q=80',
                            description: 'StYlIsH TeSt HaT'
                        },
                        {
                            name: 'TeSt ScArF 5',
                            price: 30.00,
                            image: 'https://images.unsplash.com/photo-1601925260368-ae2f83d49e5a?auto=format&fit=crop&w=400&h=400&q=80',
                            description: 'WaRm TeSt ScArF'
                        },
                        {
                            name: 'TeSt JeAnS 6',
                            price: 75.00,
                            image: 'https://images.unsplash.com/photo-1542272604-787c3835535d?auto=format&fit=crop&w=400&h=400&q=80',
                            description: 'ClAsSiC TeSt JeAnS'
                        }
                    ];
                    
                    // Combine backend products with test products
                    products = [...products, ...testProducts];
                    
                    if (products.length === 0) {
                        container.innerHTML = '<p style="text-align:center;color:#666;font-style:italic;">No fashion products yet. Add your first product in admin!</p>';
                        return;
                    }
                    
                    container.innerHTML = products.map((product, index) => {
                        const name = product.name || 'Unnamed Fashion';
                        const price = product.price || 0;
                        const image = product.image || '';
                        const description = product.description || '';
                        const imageUrl = image && image.startsWith('http') 
                            ? image 
                            : (image && image.startsWith('/') ? `http://localhost:3000${image}` : image);
                        
                        return `
                    <div class="product fashion-product" 
                         data-name="${name}" 
                         data-price="${price}" 
                         data-image="${imageUrl}" 
                         data-short="${description}" 
                         data-description="${description}">
                        <img src="${imageUrl}" alt="${name}" onload="this.style.display='block'" onerror="this.style.display='none'">
                        <div class="fashion-price-tag">
                            <span>$${price.toFixed(2)}</span>
                            <button class="fashion-add-to-cart-btn" data-name="${name}" onclick="event.stopPropagation(); if(typeof window.addToCart === 'function') { window.addToCart('${name}', ${price}, '${imageUrl}'); if(typeof window.updateButtonStates === 'function') window.updateButtonStates(); }">+ CaRt</button>
                        </div>
                    </div>
                    `;
                    }).join('');
                    
                    // Re-initialize fashion frame positioning after rendering
                    initializeFashionFrames();
                    
                    // Re-initialize category headings parallax
                    if (typeof initializeCategoryHeadingsParallax === 'function') {
                        setTimeout(() => initializeCategoryHeadingsParallax(), 50);
                    }
                    
                    // Re-initialize fashion click handlers
                    const fashionContainer = document.getElementById('fashion-products-container');
                    if (fashionContainer) {
                        // Remove old listener if exists
                        if (fashionContainer._fashionClickHandler) {
                            fashionContainer.removeEventListener('click', fashionContainer._fashionClickHandler);
                        }
                        
                        // Create new click handler for fashion
                        fashionContainer._fashionClickHandler = function(e) {
                            const fashionProduct = e.target.closest('.fashion-product');
                            if (!fashionProduct) return;
                            
                            // Don't open if clicking the add to cart button
                            if (e.target.closest('.fashion-add-to-cart-btn')) {
                                return;
                            }
                            
                            const name = fashionProduct.getAttribute('data-name');
                            const price = fashionProduct.getAttribute('data-price');
                            const image = fashionProduct.getAttribute('data-image');
                            const short = fashionProduct.getAttribute('data-short');
                            const description = fashionProduct.getAttribute('data-description');
                            
                            if (name && price && image) {
                                if (typeof window.openArtsProductDetail === 'function') {
                                    window.openArtsProductDetail(name, price, image, short || description, description, fashionProduct);
                                } else if (typeof window.openProductDetail === 'function') {
                                    window.openProductDetail(name, price, image, short || description, description);
                                }
                            }
                        };
                        
                        fashionContainer.addEventListener('click', fashionContainer._fashionClickHandler);
                    }
                } catch (error) {
                    console.error('Error rendering fashion products:', error);
                    container.innerHTML = '<p style="text-align:center;color:red;">Error displaying fashion products. Check console for details.</p>';
                }
            };
            
            // Initialize crafts frames positioning (same as fashion)
            function initializeCraftsFrames() {
                const craftsProducts = document.querySelectorAll('.category-section[data-category="crafts"] .crafts-product');
                if (craftsProducts.length === 0) return;
                
                // Remove old scroll listener if it exists
                if (window._craftsParallaxHandler) {
                    window.removeEventListener('scroll', window._craftsParallaxHandler, { passive: true });
                }
                
                // Parallax scroll handler
                let ticking = false;
                function handleParallaxScroll() {
                    if (ticking) return;
                    ticking = true;
                    
                    requestAnimationFrame(() => {
                        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                        const windowHeight = window.innerHeight;
                        
                        craftsProducts.forEach((product, index) => {
                            const rect = product.getBoundingClientRect();
                            const elementTop = rect.top + scrollY;
                            const elementCenter = elementTop + (rect.height / 2);
                            
                            // Calculate distance from viewport center
                            const viewportCenter = scrollY + (windowHeight / 2);
                            const distanceFromCenter = elementCenter - viewportCenter;
                            
                            // Parallax speed multiplier (same for all items for uniform movement)
                            const speedMultiplier = 0.08; // 3x less than 0.24 (0.24 / 3 = 0.08)
                            
                            // Calculate parallax offset
                            const parallaxOffset = distanceFromCenter * speedMultiplier;
                            
                            // Get original transform
                            const rotation = product._rotation || 0;
                            const offsetX = product._offsetX || 0;
                            const offsetY = product._offsetY || 0;
                            
                            // Apply parallax transform (moves faster than scroll)
                            const parallaxTransform = `rotate(${rotation}deg) translate(${offsetX}px, ${offsetY + parallaxOffset}px)`;
                            product.style.transform = parallaxTransform;
                        });
                        
                        ticking = false;
                    });
                }
                
                // Use same minimal rotation for all items
                const uniformRotation = (Math.random() * 6) - 3; // Minimal rotation: -3 to +3 degrees
                
                craftsProducts.forEach((product, index) => {
                    // Minimal random position offset (reduced chaos)
                    const offsetX = (Math.random() * 10) - 5; // -5px to +5px (reduced from 14px)
                    const offsetY = (Math.random() * 10) - 5; // -5px to +5px (reduced from 14px)
                    
                    // Store values for parallax calculation (same rotation for all)
                    product._rotation = uniformRotation;
                    product._offsetX = offsetX;
                    product._offsetY = offsetY;
                    
                    // Store original transform for hover (only rotation and position, no scale)
                    const baseTransform = `rotate(${uniformRotation}deg) translate(${offsetX}px, ${offsetY}px)`;
                    product._originalTransform = baseTransform;
                    
                    // Apply uniform rotation and minimal position offset
                    product.style.transform = baseTransform;
                    product.style.margin = '0';
                    
                    // Get the image element
                    const productImg = product.querySelector('img');
                    
                    // Add hover effect - only scale the image, not the product container
                    product.addEventListener('mouseenter', function() {
                        if (productImg) {
                            productImg.style.transform = 'scale(1.15)';
                        }
                    });
                    
                    product.addEventListener('mouseleave', function() {
                        if (productImg) {
                            productImg.style.transform = '';
                        }
                    });
                });
                
                // Store handler reference for cleanup
                window._craftsParallaxHandler = handleParallaxScroll;
                
                // Add scroll event listener for parallax effect
                window.addEventListener('scroll', handleParallaxScroll, { passive: true });
                
                // Initial call to set positions
                handleParallaxScroll();
            }
            
            // Initialize fashion frames positioning (chaotic layout with grid)
            function initializeFashionFrames() {
                const fashionProducts = document.querySelectorAll('.category-section[data-category="fashion"] .fashion-product');
                if (fashionProducts.length === 0) return;
                
                // Remove old scroll listener if it exists
                if (window._fashionParallaxHandler) {
                    window.removeEventListener('scroll', window._fashionParallaxHandler, { passive: true });
                }
                
                // Parallax scroll handler
                let ticking = false;
                function handleParallaxScroll() {
                    if (ticking) return;
                    ticking = true;
                    
                    requestAnimationFrame(() => {
                        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                        const windowHeight = window.innerHeight;
                        
                        fashionProducts.forEach((product, index) => {
                            const rect = product.getBoundingClientRect();
                            const elementTop = rect.top + scrollY;
                            const elementCenter = elementTop + (rect.height / 2);
                            
                            // Calculate distance from viewport center
                            const viewportCenter = scrollY + (windowHeight / 2);
                            const distanceFromCenter = elementCenter - viewportCenter;
                            
                            // Parallax speed multiplier (same for all items for uniform movement)
                            const speedMultiplier = 0.08; // 3x less than 0.24 (0.24 / 3 = 0.08)
                            
                            // Calculate parallax offset
                            const parallaxOffset = distanceFromCenter * speedMultiplier;
                            
                            // Get original transform
                            const rotation = product._rotation || 0;
                            const offsetX = product._offsetX || 0;
                            const offsetY = product._offsetY || 0;
                            
                            // Apply parallax transform (moves faster than scroll)
                            const parallaxTransform = `rotate(${rotation}deg) translate(${offsetX}px, ${offsetY + parallaxOffset}px)`;
                            product.style.transform = parallaxTransform;
                        });
                        
                        ticking = false;
                    });
                }
                
                // Use same minimal rotation for all items
                const uniformRotation = (Math.random() * 6) - 3; // Minimal rotation: -3 to +3 degrees
                
                fashionProducts.forEach((product, index) => {
                    // Minimal random position offset (reduced chaos)
                    const offsetX = (Math.random() * 10) - 5; // -5px to +5px (reduced from 14px)
                    const offsetY = (Math.random() * 10) - 5; // -5px to +5px (reduced from 14px)
                    
                    // Store values for parallax calculation (same rotation for all)
                    product._rotation = uniformRotation;
                    product._offsetX = offsetX;
                    product._offsetY = offsetY;
                    
                    // Store original transform for hover (only rotation and position, no scale)
                    const baseTransform = `rotate(${uniformRotation}deg) translate(${offsetX}px, ${offsetY}px)`;
                    product._originalTransform = baseTransform;
                    
                    // Apply uniform rotation and minimal position offset
                    product.style.transform = baseTransform;
                    product.style.margin = '0';
                    
                    // Get the image element
                    const productImg = product.querySelector('img');
                    
                    // Add hover effect - only scale the image, not the product container
                    product.addEventListener('mouseenter', function() {
                        if (productImg) {
                            productImg.style.transform = 'scale(1.15)';
                        }
                    });
                    
                    product.addEventListener('mouseleave', function() {
                        if (productImg) {
                            productImg.style.transform = '';
                        }
                    });
                });
                
                // Store handler reference for cleanup
                window._fashionParallaxHandler = handleParallaxScroll;
                
                // Add scroll event listener for parallax effect
                window.addEventListener('scroll', handleParallaxScroll, { passive: true });
                
                // Initial call to set positions
                handleParallaxScroll();
            }
            
            // Initialize music player functionality
            let currentlyPlayingMusic = null;
            let currentPlaybackSpeed = 1.0; // Store current playback speed
            let speedTransitionInterval = null; // For smooth speed transitions
            let isSpeedChanging = false; // Track if speed is currently changing
            let buttonPressStartTime = null; // Track when button was pressed
            
            function initializeMusicPlayers() {
                // Use event delegation on the container instead of individual buttons
                const musicContainer = document.getElementById('music-products-container');
                if (!musicContainer) return;
                
                // Remove old listener if exists
                if (musicContainer._musicClickHandler) {
                    musicContainer.removeEventListener('click', musicContainer._musicClickHandler);
                }
                
                // Helper function to stop current playback
                function stopCurrentPlayback() {
                    if (currentlyPlayingMusic) {
                        const prevContainer = currentlyPlayingMusic.querySelector('.youtube-player-container');
                        const prevSoundcloudContainer = currentlyPlayingMusic.querySelector('.soundcloud-player-container');
                        const prevAudio = currentlyPlayingMusic.querySelector('.audio-player');
                        const prevButton = currentlyPlayingMusic.querySelector('.play-button');
                        const prevDisc = currentlyPlayingMusic.querySelector('.record-disc');
                        currentlyPlayingMusic.classList.remove('playing');
                        if (prevButton) {
                            prevButton.classList.remove('playing');
                            prevButton.textContent = 'â–¶';
                        }
                        if (prevContainer) {
                            const iframeId = prevContainer.getAttribute('data-iframe-id');
                            if (iframeId) {
                                const iframe = document.getElementById(iframeId);
                                if (iframe) iframe.remove();
                            }
                            prevContainer.innerHTML = '';
                            prevContainer.removeAttribute('data-iframe-id');
                        }
                        if (prevSoundcloudContainer) {
                            const iframeId = prevSoundcloudContainer.getAttribute('data-iframe-id');
                            if (iframeId) {
                                const iframe = document.getElementById(iframeId);
                                if (iframe) iframe.remove();
                            }
                            prevSoundcloudContainer.innerHTML = '';
                            prevSoundcloudContainer.removeAttribute('data-iframe-id');
                        }
                        if (prevAudio) {
                            prevAudio.pause();
                            prevAudio.currentTime = 0;
                            prevAudio.playbackRate = 1.0;
                            // Clear reverse interval if exists
                            if (prevAudio._reverseInterval) {
                                clearInterval(prevAudio._reverseInterval);
                                prevAudio._reverseInterval = null;
                            }
                        }
                        // Stop vinyl spinning when playback stops
                        if (prevDisc) {
                            prevDisc.style.animation = 'none';
                            prevDisc.style.transform = 'rotate(0deg)'; // Reset to initial position
                        }
                        // Reset playback speed
                        currentPlaybackSpeed = 1.0;
                        currentlyPlayingMusic = null;
                    }
                }
                
                // Helper function to play a card
                async function playCard(card) {
                    const musicSource = card.getAttribute('data-music-source') || 'youtube';
                    const youtubeId = card.getAttribute('data-youtube-id');
                    const playButton = card.querySelector('.play-button');
                    
                    // Reset playback speed when starting a new track
                    currentPlaybackSpeed = 1.0;
                    
                    card.classList.add('playing');
                    if (playButton) {
                        playButton.classList.add('playing');
                        playButton.textContent = 'â¸';
                    }
                    
                    // Reset vinyl animation to default
                    const disc = card.querySelector('.record-disc');
                    if (disc) {
                        disc.style.animation = 'spin 3s linear infinite';
                        disc.style.transform = 'rotate(0deg)'; // Reset rotation
                    }
                    
                    // Hide speed indicator when starting new track
                    const speedIndicator = card.querySelector('.speed-indicator');
                    if (speedIndicator) {
                        speedIndicator.style.display = 'none';
                    }
                    
                    if (musicSource === 'youtube') {
                        if (!youtubeId) {
                            alert('No YouTube ID set for this track. Please add a YouTube video ID in the admin panel.');
                            return false;
                        }
                        
                        const playerContainer = card.querySelector('.youtube-player-container');
                        
                        // Create YouTube iframe for audio only (hidden but large enough for autoplay)
                        const iframe = document.createElement('iframe');
                        iframe.id = `youtube-player-${youtubeId}`;
                        iframe.src = `https://www.youtube.com/embed/${youtubeId}?autoplay=1&enablejsapi=1&controls=0&modestbranding=1&rel=0&loop=0`;
                        iframe.allow = 'autoplay; encrypted-media';
                        iframe.allowFullscreen = true;
                        iframe.style.position = 'fixed';
                        iframe.style.width = '200px';
                        iframe.style.height = '200px';
                        iframe.style.opacity = '0';
                        iframe.style.pointerEvents = 'none';
                        iframe.style.left = '-9999px';
                        iframe.style.top = '-9999px';
                        iframe.style.zIndex = '-1';
                        iframe.style.border = 'none';
                        
                        // Remove any existing iframe for this card
                        if (playerContainer) {
                            playerContainer.innerHTML = '';
                        }
                        
                        // Append to body for better autoplay support
                        document.body.appendChild(iframe);
                        
                        // Store reference in container for cleanup
                        if (playerContainer) {
                            playerContainer.setAttribute('data-iframe-id', iframe.id);
                        }
                    } else if (musicSource === 'soundcloud') {
                        const soundcloudUrl = card.getAttribute('data-soundcloud-url');
                        if (!soundcloudUrl) {
                            alert('No SoundCloud URL set for this track. Please add a SoundCloud URL in the admin panel.');
                            return false;
                        }
                        
                        const playerContainer = card.querySelector('.soundcloud-player-container');
                        
                        // Load SoundCloud Widget API script if not already loaded
                        if (!window.SC) {
                            const script = document.createElement('script');
                            script.src = 'https://w.soundcloud.com/player/api.js';
                            script.onload = function() {
                                initializeSoundCloudPlayer(card, soundcloudUrl);
                            };
                            document.head.appendChild(script);
                        } else {
                            initializeSoundCloudPlayer(card, soundcloudUrl);
                        }
                        
                        function initializeSoundCloudPlayer(card, url) {
                            const playerContainer = card.querySelector('.soundcloud-player-container');
                            
                            // SoundCloud embed format with proper parameters
                            const embedUrl = `https://w.soundcloud.com/player/?url=${encodeURIComponent(url)}&auto_play=true&hide_related=true&show_comments=false&show_user=false&show_reposts=false&visual=false&buying=false&sharing=false&download=false`;
                            
                            // Create SoundCloud iframe
                            const iframe = document.createElement('iframe');
                            iframe.id = `soundcloud-player-${Date.now()}`;
                            iframe.src = embedUrl;
                            iframe.allow = 'autoplay';
                            iframe.style.position = 'fixed';
                            iframe.style.width = '1px';
                            iframe.style.height = '1px';
                            iframe.style.opacity = '0';
                            iframe.style.pointerEvents = 'none';
                            iframe.style.left = '-9999px';
                            iframe.style.top = '-9999px';
                            iframe.style.zIndex = '-1';
                            iframe.style.border = 'none';
                            iframe.style.overflow = 'hidden';
                            
                            // Remove any existing iframe for this card
                            if (playerContainer) {
                                playerContainer.innerHTML = '';
                            }
                            
                            // Append to body for better autoplay support
                            document.body.appendChild(iframe);
                            
                            // Store reference in container for cleanup
                            if (playerContainer) {
                                playerContainer.setAttribute('data-iframe-id', iframe.id);
                            }
                            
                            // Try to use SoundCloud Widget API if available
                            if (window.SC && window.SC.Widget) {
                                try {
                                    const widget = window.SC.Widget(iframe);
                                    widget.bind(window.SC.Widget.Events.READY, function() {
                                        widget.play();
                                    });
                                } catch (e) {
                                    console.log('SoundCloud Widget API not available, using iframe autoplay');
                                }
                            }
                        }
                    } else {
                        // Uploaded audio file - find product by track title or name
                        const products = await loadProducts('music');
                        const trackTitle = card.querySelector('.music-info h3')?.textContent || '';
                        const product = products.find(p => (p.trackTitle || p.name) === trackTitle);
                        
                        if (!product || !product.audioFile) {
                            alert('No audio file found for this track. Please upload an audio file in the admin panel.');
                            return false;
                        }
                        
                        let audioPlayer = card.querySelector('.audio-player');
                        if (!audioPlayer) {
                            audioPlayer = document.createElement('audio');
                            audioPlayer.className = 'audio-player';
                            audioPlayer.style.display = 'none';
                            audioPlayer.preload = 'metadata';
                            card.appendChild(audioPlayer);
                        }
                        
                        // Handle both URL and base64 audio
                        let audioSrc = product.audioFile;
                        if (audioSrc && !audioSrc.startsWith('http') && !audioSrc.startsWith('data:')) {
                            // Relative URL - make it absolute
                            audioSrc = `http://localhost:3000${audioSrc}`;
                        }
                        audioPlayer.src = audioSrc;
                        audioPlayer.playbackRate = 1.0; // Reset to normal speed
                        audioPlayer.play().catch(err => {
                            alert('ErRoR pLaYiNg AuDiO: ' + err.message);
                            stopCurrentPlayback();
                            return false;
                        });
                    }
                    
                    currentlyPlayingMusic = card;
                    return true;
                }
                
                // Helper function to apply playback speed (called during transition)
                function applyPlaybackSpeed(speed) {
                    if (!currentlyPlayingMusic) return;
                    
                    const card = currentlyPlayingMusic;
                    const disc = card.querySelector('.record-disc');
                    
                    // Apply speed to audio element
                    const audioPlayer = card.querySelector('.audio-player');
                    if (audioPlayer) {
                        // HTML5 audio supports playbackRate (0.25 to 4.0 in most browsers)
                        const clampedSpeed = Math.max(0.25, Math.min(Math.abs(speed), 4.0));
                        audioPlayer.playbackRate = clampedSpeed;
                        
                        // For reverse: seek backward instead of negative playbackRate
                        if (speed < 0 && !audioPlayer.paused) {
                            // Clear any existing reverse interval
                            if (audioPlayer._reverseInterval) {
                                clearInterval(audioPlayer._reverseInterval);
                            }
                            // Reverse mode: smoothly seek backward
                            audioPlayer._isReversing = true;
                            const reverseSpeed = Math.abs(speed);
                            // Seek backward more frequently for smoother reverse playback
                            audioPlayer._reverseInterval = setInterval(() => {
                                if (audioPlayer.paused || !audioPlayer._isReversing) {
                                    clearInterval(audioPlayer._reverseInterval);
                                    audioPlayer._reverseInterval = null;
                                    return;
                                }
                                if (audioPlayer.currentTime > 0) {
                                    // Seek backward based on reverse speed
                                    const seekAmount = 0.05 * reverseSpeed; // Adjust for smoothness
                                    audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - seekAmount);
                                } else {
                                    // Reached beginning, stop reverse
                                    clearInterval(audioPlayer._reverseInterval);
                                    audioPlayer._reverseInterval = null;
                                    audioPlayer._isReversing = false;
                                }
                            }, 50); // Update every 50ms for smooth reverse
                        } else {
                            audioPlayer._isReversing = false;
                            if (audioPlayer._reverseInterval) {
                                clearInterval(audioPlayer._reverseInterval);
                                audioPlayer._reverseInterval = null;
                            }
                        }
                    }
                    
                    // Update vinyl spin speed and direction - linear and smooth
                    if (disc) {
                        // Only update if card is playing
                        if (card.classList.contains('playing')) {
                            const baseAnimationDuration = 3; // 3 seconds for 1x speed
                            // Linear relationship: animation duration = base / speed
                            // Higher speed = shorter duration = faster spin
                            // This creates a perfect linear correlation between music speed and vinyl speed
                            const animationDuration = baseAnimationDuration / Math.abs(speed);
                            const isReversing = speed < 0;
                            
                            // Use a simpler approach: just update the animation duration
                            // CSS animations handle the smooth transition automatically
                            // No need to preserve rotation - the animation continues naturally
                            
                            // Store the current animation if it exists to maintain continuity
                            const currentAnimation = disc.style.animation;
                            const isCurrentlySpinning = currentAnimation && currentAnimation.includes('spin');
                            
                            if (isCurrentlySpinning) {
                                // If already spinning, just update the duration smoothly
                                // CSS will handle the transition naturally
                                disc.style.animationPlayState = 'running';
                                // Extract current animation name and timing
                                const animationMatch = currentAnimation.match(/(spin\w*)\s+([\d.]+)s/);
                                if (animationMatch) {
                                    const currentName = animationMatch[1];
                                    const newName = isReversing ? 'spinReverse' : 'spin';
                                    // Only update if direction changed or duration needs update
                                    if (currentName !== newName || Math.abs(parseFloat(animationMatch[2]) - animationDuration) > 0.01) {
                                        disc.style.animation = `${newName} ${animationDuration}s linear infinite`;
                                    }
                                } else {
                                    // Fallback: set new animation
                                    disc.style.animation = `spin${isReversing ? 'Reverse' : ''} ${animationDuration}s linear infinite`;
                                }
                            } else {
                                // Start new animation
                                disc.style.animation = `spin${isReversing ? 'Reverse' : ''} ${animationDuration}s linear infinite`;
                            }
                        }
                    }
                    
                    // Don't show speed indicator - user doesn't want to see it
                }
                
                // Easing function for smooth DJ-style speed transition (exponential ease-out)
                function easeOutExpo(t) {
                    // Exponential ease-out: starts fast, slows down smoothly
                    return t === 1 ? 1 : 1 - Math.pow(2, -10 * t);
                }
                
                // Easing function for smooth DJ-style speed transition (cubic ease-in-out)
                function easeInOutCubic(t) {
                    // Smooth start and end, faster in the middle
                    return t < 0.5 
                        ? 4 * t * t * t 
                        : 1 - Math.pow(-2 * t + 2, 3) / 2;
                }
                
                // Start smooth speed transition (called on button hold)
                function startSpeedTransition(direction) {
                    if (!currentlyPlayingMusic || isSpeedChanging) return;
                    
                    // Record when button was pressed
                    buttonPressStartTime = Date.now();
                    
                    isSpeedChanging = true;
                    const startSpeed = currentPlaybackSpeed;
                    const targetSpeed = direction === 'forward' ? 15.0 : -3.0;
                    const transitionDuration = 2000; // 2 seconds
                    const startTime = Date.now();
                    
                    // Clear any existing transition
                    if (speedTransitionInterval) {
                        clearInterval(speedTransitionInterval);
                    }
                    
                    // Update speed smoothly over 2 seconds with LINEAR interpolation
                    // This ensures vinyl animation increases in speed linearly, matching music
                    // Linear means: constant rate of change, no acceleration/deceleration
                    speedTransitionInterval = setInterval(() => {
                        const elapsed = Date.now() - startTime;
                        const linearProgress = Math.min(elapsed / transitionDuration, 1); // 0 to 1, pure linear
                        
                        // Pure linear interpolation - smooth, constant rate speed increase
                        // Vinyl animation speed will increase linearly at the same rate as music
                        // Formula: speed(t) = startSpeed + (targetSpeed - startSpeed) * t
                        // This creates a perfect linear relationship between time and speed
                        const newSpeed = startSpeed + (targetSpeed - startSpeed) * linearProgress;
                        currentPlaybackSpeed = newSpeed;
                        
                        // Apply the new speed immediately - this updates both music and vinyl linearly
                        applyPlaybackSpeed(newSpeed);
                        
                        // Stop when target is reached
                        if (linearProgress >= 1) {
                            clearInterval(speedTransitionInterval);
                            speedTransitionInterval = null;
                            isSpeedChanging = false;
                        }
                    }, 16); // ~60fps updates for ultra-smooth linear animation
                }
                
                // Stop speed transition and return to 1x (called on button release)
                function stopSpeedTransition() {
                    if (!currentlyPlayingMusic) return;
                    
                    // Check how long button was held
                    const buttonHoldDuration = buttonPressStartTime ? Date.now() - buttonPressStartTime : 0;
                    buttonPressStartTime = null;
                    
                    // Clear any existing transition
                    if (speedTransitionInterval) {
                        clearInterval(speedTransitionInterval);
                        speedTransitionInterval = null;
                    }
                    
                    // Always return to 1x instantly (0 seconds)
                    currentPlaybackSpeed = 1.0;
                    applyPlaybackSpeed(1.0);
                    isSpeedChanging = false;
                    
                    // Fade out speed indicator after reaching 1x
                    if (currentlyPlayingMusic) {
                        const speedIndicator = currentlyPlayingMusic.querySelector('.speed-indicator');
                        if (speedIndicator) {
                            setTimeout(() => {
                                if (speedIndicator) {
                                    speedIndicator.style.opacity = '0';
                                    setTimeout(() => {
                                        if (speedIndicator) speedIndicator.style.display = 'none';
                                    }, 1000);
                                }
                            }, 1000);
                        }
                    }
                }
                
                // Create new handler for play/pause
                musicContainer._musicClickHandler = function(e) {
                    const skipButton = e.target.closest('.skip-button');
                    const playButton = e.target.closest('.play-button');
                    
                    // Skip buttons are handled separately with mousedown/mouseup
                    if (skipButton) {
                        e.stopPropagation();
                        return;
                    }
                    
                    if (!playButton) return;
                    
                    e.stopPropagation();
                    const card = playButton.closest('.record-player-card');
                    if (!card) return;
                    
                    const youtubeId = card.getAttribute('data-youtube-id');
                    const playerContainer = card.querySelector('.youtube-player-container');
                    const isPlaying = card.classList.contains('playing');
                    
                    // Stop any currently playing card
                    if (currentlyPlayingMusic && currentlyPlayingMusic !== card) {
                        stopCurrentPlayback();
                    }
                    
                    if (isPlaying) {
                        // Pause/Stop
                        const audioPlayer = card.querySelector('.audio-player');
                        if (audioPlayer && audioPlayer._reverseInterval) {
                            // Stop reverse interval if active
                            clearInterval(audioPlayer._reverseInterval);
                            audioPlayer._reverseInterval = null;
                            audioPlayer._isReversing = false;
                        }
                        stopCurrentPlayback();
                    } else {
                        // Play - hidden audio only
                        playCard(card);
                    }
                };
                
                // Attach click listener for play/pause
                musicContainer.addEventListener('click', musicContainer._musicClickHandler);
                
                // Attach mousedown/mouseup listeners for speed control (hold to change speed)
                musicContainer.addEventListener('mousedown', function(e) {
                    const skipButton = e.target.closest('.skip-button');
                    if (!skipButton) return;
                    
                    e.stopPropagation();
                    e.preventDefault();
                    
                    if (!currentlyPlayingMusic) return;
                    
                    const action = skipButton.getAttribute('data-action');
                    const direction = action === 'skip-forward' ? 'forward' : 'backward';
                    startSpeedTransition(direction);
                });
                
                musicContainer.addEventListener('mouseup', function(e) {
                    const skipButton = e.target.closest('.skip-button');
                    if (!skipButton) return;
                    
                    e.stopPropagation();
                    e.preventDefault();
                    
                    stopSpeedTransition();
                });
                
                // Also handle mouseleave to stop transition if mouse leaves button
                musicContainer.addEventListener('mouseleave', function(e) {
                    stopSpeedTransition();
                });
                
                // Touch events for mobile
                musicContainer.addEventListener('touchstart', function(e) {
                    const skipButton = e.target.closest('.skip-button');
                    if (!skipButton) return;
                    
                    e.stopPropagation();
                    e.preventDefault();
                    
                    if (!currentlyPlayingMusic) return;
                    
                    const action = skipButton.getAttribute('data-action');
                    const direction = action === 'skip-forward' ? 'forward' : 'backward';
                    startSpeedTransition(direction);
                });
                
                musicContainer.addEventListener('touchend', function(e) {
                    const skipButton = e.target.closest('.skip-button');
                    if (!skipButton) return;
                    
                    e.stopPropagation();
                    e.preventDefault();
                    
                    stopSpeedTransition();
                });
            }
            
            // Initialize category headings parallax effect (slower than scroll)
            function initializeCategoryHeadingsParallax() {
                const headings = document.querySelectorAll('.category-section-heading, .category-subheading');
                if (headings.length === 0) return;
                
                // Remove old scroll listener if it exists
                if (window._categoryHeadingsParallaxHandler) {
                    window.removeEventListener('scroll', window._categoryHeadingsParallaxHandler, { passive: true });
                }
                
                // Store original positions
                headings.forEach(heading => {
                    if (!heading._originalTop) {
                        const rect = heading.getBoundingClientRect();
                        heading._originalTop = rect.top + window.pageYOffset;
                    }
                });
                
                // Parallax scroll handler - moves slower than scroll (negative parallax)
                let ticking = false;
                function handleParallaxScroll() {
                    if (ticking) return;
                    ticking = true;
                    
                    requestAnimationFrame(() => {
                        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
                        const windowHeight = window.innerHeight;
                        
                        headings.forEach(heading => {
                            const rect = heading.getBoundingClientRect();
                            const elementTop = rect.top + scrollY;
                            const elementCenter = elementTop + (rect.height / 2);
                            
                            // Calculate distance from viewport center
                            const viewportCenter = scrollY + (windowHeight / 2);
                            const distanceFromCenter = elementCenter - viewportCenter;
                            
                            // Negative parallax speed multiplier (moves slower than scroll)
                            // Negative value means it moves in opposite direction (slower)
                            const speedMultiplier = -0.05; // Moves 5% slower than scroll (2x less than -0.1)
                            
                            // Calculate parallax offset (negative = moves up slower)
                            const parallaxOffset = distanceFromCenter * speedMultiplier;
                            
                            // Apply parallax transform (moves slower than scroll)
                            heading.style.transform = `translateY(${parallaxOffset}px)`;
                        });
                        
                        ticking = false;
                    });
                }
                
                // Store handler reference for cleanup
                window._categoryHeadingsParallaxHandler = handleParallaxScroll;
                
                // Add scroll event listener for parallax effect
                window.addEventListener('scroll', handleParallaxScroll, { passive: true });
                
                // Initial call to set positions
                handleParallaxScroll();
            }
            
            // Initialize: Render coffee and music products on page load
            document.addEventListener('DOMContentLoaded', async function() {
                await renderCoffeeProducts();
                await renderMusicProducts();
                await renderArtsProducts();
                await renderFashionProducts();
                await renderCraftsProducts();
                
                // Initialize category headings parallax after a short delay to ensure DOM is ready
                setTimeout(() => {
                    initializeCategoryHeadingsParallax();
                }, 100);
            });
        })();
    </script>
    
    <script>
        // Marquee alternating effect on load
        document.addEventListener('DOMContentLoaded', function() {
            const marquee = document.querySelector('marquee');
            if (!marquee) return;
            
            // Pattern: s2s1s2s1s2s2s1s2s2s1 (10 positions, each 0.5s = 5 seconds total)
            // Situation 1: background white, text red
            // Situation 2: background red, text white
            const pattern = [2, 1, 2, 1, 2, 2, 1, 2, 2, 1];
            let position = 0;
            
            const changeStyle = function(situation) {
                if (situation === 1) {
                    // Situation 1: marquee color white, text color red
                    marquee.style.background = '#ffffff';
                    marquee.style.color = '#f64b23';
                } else {
                    // Situation 2: marquee color red, text color white
                    marquee.style.background = '#f64b23';
                    marquee.style.color = '#ffffff';
                }
            };
            
            const interval = setInterval(function() {
                if (position < pattern.length) {
                    changeStyle(pattern[position]);
                    position++;
                } else {
                    clearInterval(interval);
                    // After 5 seconds, stay in situation 1
                    changeStyle(1);
                }
            }, 500); // 0.5 seconds per position
        });
    </script>
</body>
</html>




